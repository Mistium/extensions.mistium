// Name: Simple 3D
// ID: xeltallivSimple3D
// Description: Make GPU accelerated 3D projects easily.
// By: Vadik1 <https://scratch.mit.edu/users/Vadik1/>
// License: MPL-2.0 AND BSD-3-Clause
// Version: 1.2.2
// Why?: This has been modified for file size optimisation in https://origin.mistium.com

!function(e){"use strict";const t={perspective(e,t,r,n){const a=Math.tan(.5*Math.PI-.5*e),o=1/(r-n);return[a/t,0,0,0,0,a,0,0,0,0,(r+n)*o,-1,0,0,r*n*o*2,0]},orthographic(e,t,r){const n=2/(t-r);return[1/e,0,0,0,0,1,0,0,0,0,n,0,0,0,t*n-1,1]},translate:(e,t,r,n)=>[e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],t*e[0]+r*e[4]+n*e[8]+e[12],t*e[1]+r*e[5]+n*e[9]+e[13],t*e[2]+r*e[6]+n*e[10]+e[14],t*e[3]+r*e[7]+n*e[11]+e[15]],xRotate(e,t){const r=Math.cos(t),n=Math.sin(t);return[e[0],e[1],e[2],e[3],r*e[4]+n*e[8],r*e[5]+n*e[9],r*e[6]+n*e[10],r*e[7]+n*e[11],r*e[8]-n*e[4],r*e[9]-n*e[5],r*e[10]-n*e[6],r*e[11]-n*e[7],e[12],e[13],e[14],e[15]]},yRotate(e,t){const r=Math.cos(t),n=Math.sin(t);return[r*e[0]-n*e[8],r*e[1]-n*e[9],r*e[2]-n*e[10],r*e[3]-n*e[11],e[4],e[5],e[6],e[7],n*e[0]+r*e[8],n*e[1]+r*e[9],n*e[2]+r*e[10],n*e[3]+r*e[11],e[12],e[13],e[14],e[15]]},zRotate(e,t){const r=Math.cos(t),n=Math.sin(t);return[r*e[0]+n*e[4],r*e[1]+n*e[5],r*e[2]+n*e[6],r*e[3]+n*e[7],r*e[4]-n*e[0],r*e[5]-n*e[1],r*e[6]-n*e[2],r*e[7]-n*e[3],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15]]},scale:(e,t,r,n)=>[t*e[0],t*e[1],t*e[2],t*e[3],r*e[4],r*e[5],r*e[6],r*e[7],n*e[8],n*e[9],n*e[10],n*e[11],e[12],e[13],e[14],e[15]],multiply(e,t){const r=e[0],n=e[1],a=e[2],o=e[3],s=e[4],i=e[5],l=e[6],u=e[7],f=e[8],d=e[9],c=e[10],p=e[11],m=e[12],h=e[13],T=e[14],E=e[15],N=t[0],R=t[1],A=t[2],g=t[3],b=t[4],y=t[5],S=t[6],x=t[7],M=t[8],_=t[9],I=t[10],O=t[11],v=t[12],D=t[13],U=t[14],C=t[15];return[N*r+R*s+A*f+g*m,N*n+R*i+A*d+g*h,N*a+R*l+A*c+g*T,N*o+R*u+A*p+g*E,b*r+y*s+S*f+x*m,b*n+y*i+S*d+x*h,b*a+y*l+S*c+x*T,b*o+y*u+S*p+x*E,M*r+_*s+I*f+O*m,M*n+_*i+I*d+O*h,M*a+_*l+I*c+O*T,M*o+_*u+I*p+O*E,v*r+D*s+U*f+C*m,v*n+D*i+U*d+C*h,v*a+D*l+U*c+C*T,v*o+D*u+U*p+C*E]},multiplyVec:function(e,t){const r=e[0],n=e[1],a=e[2],o=e[3],s=e[4],i=e[5],l=e[6],u=e[7],f=e[8],d=e[9],c=e[10],p=e[11],m=e[12],h=e[13],T=e[14],E=e[15],N=t[0],R=t[1],A=t[2],g=t[3];return[N*r+R*s+A*f+g*m,N*n+R*i+A*d+g*h,N*a+R*l+A*c+g*T,N*o+R*u+A*p+g*E]},identity:()=>[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],zero:function(){return[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},inverse:function(e){const r=[e[5]*e[10]*e[15]-e[5]*e[11]*e[14]-e[9]*e[6]*e[15]+e[9]*e[7]*e[14]+e[13]*e[6]*e[11]-e[13]*e[7]*e[10],-e[1]*e[10]*e[15]+e[1]*e[11]*e[14]+e[9]*e[2]*e[15]-e[9]*e[3]*e[14]-e[13]*e[2]*e[11]+e[13]*e[3]*e[10],e[1]*e[6]*e[15]-e[1]*e[7]*e[14]-e[5]*e[2]*e[15]+e[5]*e[3]*e[14]+e[13]*e[2]*e[7]-e[13]*e[3]*e[6],-e[1]*e[6]*e[11]+e[1]*e[7]*e[10]+e[5]*e[2]*e[11]-e[5]*e[3]*e[10]-e[9]*e[2]*e[7]+e[9]*e[3]*e[6],-e[4]*e[10]*e[15]+e[4]*e[11]*e[14]+e[8]*e[6]*e[15]-e[8]*e[7]*e[14]-e[12]*e[6]*e[11]+e[12]*e[7]*e[10],e[0]*e[10]*e[15]-e[0]*e[11]*e[14]-e[8]*e[2]*e[15]+e[8]*e[3]*e[14]+e[12]*e[2]*e[11]-e[12]*e[3]*e[10],-e[0]*e[6]*e[15]+e[0]*e[7]*e[14]+e[4]*e[2]*e[15]-e[4]*e[3]*e[14]-e[12]*e[2]*e[7]+e[12]*e[3]*e[6],e[0]*e[6]*e[11]-e[0]*e[7]*e[10]-e[4]*e[2]*e[11]+e[4]*e[3]*e[10]+e[8]*e[2]*e[7]-e[8]*e[3]*e[6],e[4]*e[9]*e[15]-e[4]*e[11]*e[13]-e[8]*e[5]*e[15]+e[8]*e[7]*e[13]+e[12]*e[5]*e[11]-e[12]*e[7]*e[9],-e[0]*e[9]*e[15]+e[0]*e[11]*e[13]+e[8]*e[1]*e[15]-e[8]*e[3]*e[13]-e[12]*e[1]*e[11]+e[12]*e[3]*e[9],e[0]*e[5]*e[15]-e[0]*e[7]*e[13]-e[4]*e[1]*e[15]+e[4]*e[3]*e[13]+e[12]*e[1]*e[7]-e[12]*e[3]*e[5],-e[0]*e[5]*e[11]+e[0]*e[7]*e[9]+e[4]*e[1]*e[11]-e[4]*e[3]*e[9]-e[8]*e[1]*e[7]+e[8]*e[3]*e[5],-e[4]*e[9]*e[14]+e[4]*e[10]*e[13]+e[8]*e[5]*e[14]-e[8]*e[6]*e[13]-e[12]*e[5]*e[10]+e[12]*e[6]*e[9],e[0]*e[9]*e[14]-e[0]*e[10]*e[13]-e[8]*e[1]*e[14]+e[8]*e[2]*e[13]+e[12]*e[1]*e[10]-e[12]*e[2]*e[9],-e[0]*e[5]*e[14]+e[0]*e[6]*e[13]+e[4]*e[1]*e[14]-e[4]*e[2]*e[13]-e[12]*e[1]*e[6]+e[12]*e[2]*e[5],e[0]*e[5]*e[10]-e[0]*e[6]*e[9]-e[4]*e[1]*e[10]+e[4]*e[2]*e[9]+e[8]*e[1]*e[6]-e[8]*e[2]*e[5]],n=e[0]*r[0]+e[1]*r[4]+e[2]*r[8]+e[3]*r[12];if(0==n)return t.zero();const a=1/n;for(let e=0;e<16;e++)r[e]*=a;return r}},r=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);class n{constructor(e){this.buffer=_.createBuffer(),this.bytesPerEl=1,this.size=1,this.length=0,this.type=e}destroy(){_.deleteBuffer(this.buffer)}}class a{constructor(){this.destroyed=!1,this.viewport=null,this.scissors=null,this.readarea=null}setAsRenderTarget(){X=this,_.bindFramebuffer(_.FRAMEBUFFER,this.getFramebuffer()),this.updateViewport(),this.updateDepth(),this.updateScissorsEnabled()}updateScissorsEnabled(){this.scissors?_.enable(_.SCISSOR_TEST):_.disable(_.SCISSOR_TEST)}updateViewport(){const e=this.viewport,t=this.scissors;e?_.viewport(e.x,e.y,e.w,e.h):_.viewport(0,0,this.width,this.height),t&&_.scissor(t.x,t.y,t.w,t.h)}getReadarea(){return this.readarea?this.readarea:{x:0,y:0,w:this.width,h:this.height}}updateDepth(){"everything"!=this.depthTest||this.depthWrite?(_.enable(_.DEPTH_TEST),_.depthFunc(U[this.depthTest]),_.depthMask(this.depthWrite)):_.disable(_.DEPTH_TEST)}getAspectRatio(){return 0==this.width?1:this.width/this.height}destroy(){this.destroyed=!0}}class o{constructor(e,t){this.mesh=t,this.target=e,this.texture=_.createTexture(),this.width=0,this.height=0,this.depthTest="everything",this.depthWrite=!1,this.wrap=_.CLAMP_TO_EDGE,this.filter=_.NEAREST,this.mipFilter=_.NEAREST,this.mipEnabled=!1,this.anisotropy=1,this.hasDepthBuffer=!1,this.update()}bindTexture(){_.bindTexture(this.target,this.texture)}update(){let e=this.filter;if(this.mipEnabled){e=[[_.NEAREST_MIPMAP_NEAREST,_.NEAREST_MIPMAP_LINEAR],[_.LINEAR_MIPMAP_NEAREST,_.LINEAR_MIPMAP_LINEAR]][+(this.filter==_.LINEAR)][+(this.mipFilter==_.LINEAR)]}_.bindTexture(this.target,this.texture),_.texParameteri(this.target,_.TEXTURE_WRAP_S,this.wrap),_.texParameteri(this.target,_.TEXTURE_WRAP_T,this.wrap),_.texParameteri(this.target,_.TEXTURE_MIN_FILTER,e),_.texParameteri(this.target,_.TEXTURE_MAG_FILTER,this.filter)}setTextureProps(e,t,r,n,a){const o=this.width!==t||this.height!==r;if(this.width=t,this.height=r,this.wrap=n,this.filter=a,o)for(const n of this.sides)n!==e&&n.resetTexture(t,r);this.update(),this.maybeRegenMipmap(),I&&_.texParameterf(this.target,I.TEXTURE_MAX_ANISOTROPY_EXT,this.anisotropy)}setMipmapState(e,t){this.mipEnabled=e,this.mipFilter=t,this.update(),this.maybeRegenMipmap()}setAnisotropy(e){I&&(this.anisotropy=e,_.bindTexture(this.target,this.texture),this.maybeRegenMipmap(),_.texParameterf(this.target,I.TEXTURE_MAX_ANISOTROPY_EXT,e))}maybeRegenMipmap(){!(this.mipEnabled||this.anisotropy>1)||this.isLoading()||this.hasFailedToLoad()||_.generateMipmap(this.target)}setDepth(e,t){if(this.depthTest=e,this.depthWrite=t,!this.hasDepthBuffer&&t){this.hasDepthBuffer=!0;for(let e of this.sides)e.createDepthBuffer()}}isLoading(){for(const e of this.sides)if(e.loading)return!0;return!1}hasFailedToLoad(){for(const e of this.sides)if(e.failedToLoad)return!0;return!1}destroy(){_.deleteTexture(this.texture);for(const e of this.sides)e.destroy()}}class s extends o{constructor(e){super(_.TEXTURE_2D,e),this.main=new l(this,_.TEXTURE_2D),this.sides=[this.main]}}class i extends o{constructor(e){super(_.TEXTURE_CUBE_MAP,e),this.xpos=new l(this,_.TEXTURE_CUBE_MAP_POSITIVE_X),this.xneg=new l(this,_.TEXTURE_CUBE_MAP_NEGATIVE_X),this.ypos=new l(this,_.TEXTURE_CUBE_MAP_POSITIVE_Y),this.yneg=new l(this,_.TEXTURE_CUBE_MAP_NEGATIVE_Y),this.zpos=new l(this,_.TEXTURE_CUBE_MAP_POSITIVE_Z),this.zneg=new l(this,_.TEXTURE_CUBE_MAP_NEGATIVE_Z),this.sides=[this.xpos,this.xneg,this.ypos,this.yneg,this.zpos,this.zneg]}}class l extends a{constructor(e,t){super(),this.shared=e,this.target=t,this.depthTexture=null,this.framebuffer=null,this.loading=!1,this.failedToLoad=!1,this.uninitialized=!0}resetTexture(e,t){this.uninitialized=!1,_.texImage2D(this.target,0,_.RGBA,e,t,0,_.RGBA,_.UNSIGNED_BYTE,null),this.depthTexture&&(_.bindRenderbuffer(_.RENDERBUFFER,this.depthTexture),_.renderbufferStorage(_.RENDERBUFFER,_.DEPTH_COMPONENT24,e,t)),X==this&&this.updateViewport()}setTexture(e,t,r,n,a){this.uninitialized=!1,this.loading=!1,this.failedToLoad=!1,this.shared.bindTexture(),e instanceof HTMLImageElement||e instanceof HTMLCanvasElement?_.texImage2D(this.target,0,_.RGBA,_.RGBA,_.UNSIGNED_BYTE,e):_.texImage2D(this.target,0,_.RGBA,t,r,0,_.RGBA,_.UNSIGNED_BYTE,e),this.shared.setTextureProps(this,t,r,n,a),this.depthTexture&&(_.bindRenderbuffer(_.RENDERBUFFER,this.depthTexture),_.renderbufferStorage(_.RENDERBUFFER,_.DEPTH_COMPONENT24,t,r)),X==this&&this.updateViewport()}getFramebuffer(){return this.framebuffer||(this.framebuffer=_.createFramebuffer(),_.bindFramebuffer(_.FRAMEBUFFER,this.framebuffer),_.framebufferTexture2D(_.FRAMEBUFFER,_.COLOR_ATTACHMENT0,this.target,this.shared.texture,0)),this.framebuffer}createDepthBuffer(){const e=this.getFramebuffer();_.bindFramebuffer(_.FRAMEBUFFER,e),this.depthTexture=_.createRenderbuffer(),_.bindRenderbuffer(_.RENDERBUFFER,this.depthTexture),_.renderbufferStorage(_.RENDERBUFFER,_.DEPTH_COMPONENT24,this.width,this.height),_.framebufferRenderbuffer(_.FRAMEBUFFER,_.DEPTH_ATTACHMENT,_.RENDERBUFFER,this.depthTexture)}get depthTest(){return this.shared.depthTest}get depthWrite(){return this.shared.depthWrite}get width(){return this.shared.width}get height(){return this.shared.height}get hasDepthBuffer(){return this.shared.hasDepthBuffer}setDepth(e,t){this.shared.setDepth(e,t)}getMesh(){return this.shared.mesh}checkIfValid(){return!(this.uninitialized||this.destroyed)}destroy(){this.depthTexture&&_.deleteRenderbuffer(this.depthTexture),this.framebuffer&&_.deleteFramebuffer(this.framebuffer),super.destroy()}}class u{constructor(e){this.name=e,this.buffers={},this.myBuffers={},this.data={},this.myData={},this.uploadOffset=-1,this.uploadUsage=_.STATIC_DRAW,this.dependants=new Set,this.dependencies=new Set}update(){const e={},t={};for(const r of this.dependencies)Object.assign(e,r.buffers),Object.assign(t,r.data);this.buffers=Object.assign(e,this.myBuffers),this.data=Object.assign(t,this.myData);for(const e of this.dependants)e.update()}dependsOn(e){if(e==this)return!0;for(const t of this.dependencies)if(t.dependsOn(e))return!0;return!1}checkIfValid(){if(X.getMesh()==this)return!1;if(!this.buffers.position)return!1;let e=-1,t=-1;for(const r in this.buffers){const n=this.buffers[r];if(0==n.type){if(-1==e)e=n.length;else if(e!==n.length)return!1}else if(1==n.type)if(-1==t)t=n.length;else if(t!==n.length)return!1}return-1!=e}estimateListVRAM(){let e=0;for(const t in this.myBuffers){const r=this.myBuffers[t];e+=r.length*r.size*r.bytesPerEl}return e}estimateTextureVRAM(){const e=this.myData.texture;if(!e)return 0;let t=e.width*e.height*4;return e.hasDepthBuffer&&(t*=2),e instanceof i&&(t*=6),t}estimateVRAM(){return this.estimateListVRAM()+this.estimateTextureVRAM()}destroy(){for(let e in this.myBuffers)this.myBuffers[e].destroy();this.myData.texture?.destroy();for(const e of this.dependants)e.dependencies.delete(this);for(const e of this.dependencies)e.dependants.delete(this);for(const e of this.dependants)e.update()}}const f={"inherits from":e=>Array.from(e.dependencies).map((e=>e.name)).join(","),"is inherited by":e=>Array.from(e.dependants).map((e=>e.name)).join(","),"is valid for drawing":e=>e.checkIfValid(),"has vertex indices":e=>!!e.buffers.indices,"has positions":e=>!!e.buffers.position,"has colors":e=>!!e.buffers.colors,"has texture coordinates":e=>!!e.buffers.texCoords,"has bone indices/weights":e=>!!e.buffers.boneIndices,"has bones":e=>!!e.data.bonesDiff,"has instanced positions":e=>!!e.buffers.instanceTransforms,"has instanced colors":e=>!!e.buffers.instanceColors,"has instanced uvs":e=>!!e.buffers.instanceUVOffsets,"has texture":e=>!!e.data.texture,"texture width":e=>e.data.texture?.width,"texture height":e=>e.data.texture?.height,"texture stores depth":e=>e.data.texture?.hasDepthBuffer,"texture depth write":e=>e.data.texture?.depthWrite,"texture depth test":e=>e.data.texture?.depthTest,"texture is 2D":e=>e.data.texture instanceof s,"texture is cube":e=>e.data.texture instanceof i,"texture is loading":e=>e.data.texture?.isLoading?.(),"texture has failed to load":e=>e.data.texture?.hasFailedToLoad?.(),"primitive type":e=>e.data.primitivesName??"triangles","blending type":e=>e.data.blending??"default","culling type":e=>e.data.culling??"nothing","alpha threshold":e=>e.data.alphaTest??0,"makes opaque":e=>!!e.data.makeOpaque,"has billboarding":e=>!!e.data.billboarding,"has vertex draw range":e=>!!e.data.drawRange,"vertex draw range start":e=>e.data.drawRange&&e.data.drawRange[0]+1,"vertex draw range end":e=>e.data.drawRange&&e.data.drawRange[0]+e.data.drawRange[1],"vertex draw range length":e=>e.data.drawRange&&e.data.drawRange[1],"instance draw limit":e=>e.data.maxInstances??1/0,"partial list update enabled":e=>e.uploadOffset>=0,"estimate own VRAM usage":e=>e.estimateVRAM(),"estimate own list VRAM usage":e=>e.estimateListVRAM(),"estimate own texture VRAM usage":e=>e.estimateTextureVRAM()};let d='\n  class OffModelImporter {\n    constructor(dataRaw) {\n      const dataStr = dataRaw.map(str => str.split("#")[0].replaceAll("\t", " ").trim()).filter(str => str.length);\n      const dataArr = dataStr.map(str => str.split(" ").filter(e => e));\n      let i = 0;\n      if (dataStr[i].endsWith("OFF")) i++;\n      if (dataArr[i].length !== 3) return false;\n      const [vertexCount, faceCount, edgeCount] = dataArr[i].map(n => +n); i++;\n      const vertices = dataArr.slice(i, i+vertexCount); i += vertexCount;\n      const faces = dataArr.slice(i, i+faceCount); i += faceCount;\n      this.vertices = vertices;\n      this.output = {\n        xyz: [],\n        rgba: []\n      }\n      for(const face of faces) {\n        const nVerts = +face[0];\n        this.addPoly(face.slice(1, 1+nVerts), face.slice(1+nVerts));\n      }\n      let hasColor = false;\n      const rgba = this.output.rgba;\n      for(let i=0; i<rgba.length; i++) {\n        if (rgba[i] < 1) {\n          hasColor = true;\n          break;\n        }\n      }\n      if (!hasColor) delete this.output.rgba;\n    }\n    addPoly(vs, fallback) {\n      fallback = fallback.map(this.parseColor);\n      if (fallback.length == 3) fallback.push(1);\n      for(let i=2; i<vs.length; i++) {\n        this.addVertex(vs[  0], fallback);\n        this.addVertex(vs[i-1], fallback);\n        this.addVertex(vs[  i], fallback);\n      }\n    }\n    addVertex(idx, fallback) {\n      const v = this.vertices[idx];\n      this.output.xyz.push(+v[0], +v[1], +v[2]);\n      this.output.rgba.push(this.parseColor(v[3]) ?? fallback[0] ?? 1, this.parseColor(v[4]) ?? fallback[1] ?? 1, this.parseColor(v[5]) ?? fallback[2] ?? 1, this.parseColor(v[6]) ?? fallback[3] ?? 1);\n    }\n    parseColor(string) {\n      const number = +string;\n      if (!Number.isFinite(number)) return undefined;\n      if (string.indexOf(".") == -1) return number / 255;\n      return number;\n    }\n  }\n  class ObjModelImporter {\n    constructor(dataRaw) {\n      const dataStr = dataRaw.map(str => str.replaceAll("\t", " ").trim()).filter(str => str.length && str[0] !== "#");\n      const dataArr = dataStr.map(str => str.split(" ").filter(e => e));\n      const materials = {" ": [1,1,1,1]};\n      let materialLast = " ";\n      let materialUsed = " ";\n      const vertPos = this.vertPos = [null];\n      const vertUV = this.vertUV = [null];\n      this.output = {\n        xyz: [],\n        rgba: [],\n        uv: []\n      }\n      for(let i=0; i<dataArr.length; i++) {\n        const arr = dataArr[i];\n        if (arr[0] == "v") {\n          vertPos.push(arr.slice(1).map(Number));\n        }\n        if (arr[0] == "vt") {\n          vertUV.push([+arr[1], +arr[2]]);\n        }\n        if (arr[0] == "f") {\n          this.addPoly(arr.slice(1).map(e => e.split("/").map(Number)), materials[materialUsed]);\n        }\n        if (arr[0] == "usemtl") {\n          materialUsed = materials[arr[1]] ? arr[1] : " ";\n        }\n        if (arr[0] == "newmtl") {\n          materialLast = arr[1];\n          materials[materialLast] = [1,1,1,1];\n        }\n        if (arr[0] == "Kd") {\n          const color = materials[materialLast];\n          color[0] = +arr[1];\n          color[1] = +arr[2];\n          color[2] = +arr[3];\n        }\n        if (arr[0] == "d") {\n          const color = materials[materialLast];\n          color[3] = +arr[1];\n        }\n        if (arr[0] == "Tr") {\n          const color = materials[materialLast];\n          color[3] = 1 - arr[1];\n        }\n      }\n      if (this.output.uv.length/2 !== this.output.rgba.length/4) {\n        this.output.uv = null;\n      }\n    }\n    addPoly(vs, fallback) {\n      for(let i=2; i<vs.length; i++) {\n        this.addVertex(vs[  0][0], vs[  0][1], fallback);\n        this.addVertex(vs[i-1][0], vs[i-1][1], fallback);\n        this.addVertex(vs[  i][0], vs[  i][1], fallback);\n      }\n    }\n    addVertex(idx, idxUV, fallback) {\n      const v = this.vertPos[idx>0 ? idx : this.vertPos.length+idx];\n      this.output.xyz.push(v[0], v[1], v[2]);\n      this.output.rgba.push(v[3] ?? fallback[0] ?? 1, v[4] ?? fallback[1] ?? 1, v[5] ?? fallback[2] ?? 1, v[6] ?? fallback[3] ?? 1);\n      if (idxUV !== undefined) {\n        const u = this.vertUV[idxUV>0 ? idxUV : this.vertUV.length+idxUV];\n        this.output.uv.push(u[0], 1-u[1]);\n      }\n    }\n  }\n  onmessage = (evt) => {\n    const {type, array, importMatrix} = evt.data;\n    let output = null;\n    try {\n      let model = null;\n      if (type == "obj mtl") model = new ObjModelImporter(array);\n      if (type == "off") model = new OffModelImporter(array);\n      if (!model) return;\n      output = model.output;\n      if (output.xyz) {\n        const xyz = output.xyz;\n        let needsScaling = false;\n        for(let i=0; i<16; i++) {\n          if (importMatrix[i] !== +(i%5 == 0)) {\n            needsScaling = true;\n          }\n        }\n        const a = importMatrix;\n        if (needsScaling) {\n          for(let i=0; i<xyz.length; i+=3) {\n            const x = xyz[i];\n            const y = xyz[i+1];\n            const z = xyz[i+2];\n            xyz[i  ] = x * a[0] + y * a[4] + z * a[8] + a[12];\n            xyz[i+1] = x * a[1] + y * a[5] + z * a[9] + a[13];\n            xyz[i+2] = x * a[2] + y * a[6] + z * a[10] + a[14];\n          }\n        }\n      }\n      if (output.rgba) {\n        const rgba = output.rgba;\n        for(let i=0; i<rgba.length; i++) {\n          rgba[i] *= 255;\n        }\n      }\n    } catch(e) {\n      output = null;\n      console.error(e);\n    }\n    postMessage(output);\n  }\n  ';class c extends e.vm.renderer.exports.Skin{constructor(e,t){super(e,t);const r=t.gl,n=r.createTexture();r.bindTexture(r.TEXTURE_2D,n),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST),this._texture=n,this._nativeSize=t.getNativeSize(),this._boundOnNativeSizeChanged=this.onNativeSizeChanged.bind(this),this._rotationCenter=[this._nativeSize[0]/2,this._nativeSize[1]/2],t.on("NativeSizeChanged",this._boundOnNativeSizeChanged),this.resizeCanvas()}dispose(){b.removeListener("NativeSizeChanged",this._boundOnNativeSizeChanged),this._texture&&(this._renderer.gl.deleteTexture(this._texture),this._texture=null),super.dispose()}get size(){return this._nativeSize}getTexture(e){return this._texture||super.getTexture()}updateContent(){const e=this._renderer.gl;e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0),e.bindTexture(e.TEXTURE_2D,this._texture),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,M),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),this._silhouette.update(M),this.emitWasAltered()}resizeCanvas(){b.useHighQualityRender?(M.width=b.canvas.width,M.height=b.canvas.height):(M.width=this._nativeSize[0],M.height=this._nativeSize[1]),X==k&&X.updateViewport(),y.startHats(`${S}_whenCanvasResized`),this.updateContent()}onNativeSizeChanged(e){this._nativeSize=e.newSize,this._rotationCenter=[this._nativeSize[0]/2,this._nativeSize[1]/2],this.resizeCanvas()}}let p="\n#ifdef MSAA_CENTROID\n#define INTERPOLATION centroid\n#endif\n#ifdef MSAA_SAMPLE\n#extension GL_OES_shader_multisample_interpolation : require\n#define INTERPOLATION sample\n#endif\n#ifndef INTERPOLATION\n#define INTERPOLATION\n#endif\n\nprecision highp float;\n\nin vec4 a_position;\n#ifdef COLORS\nin vec4 a_color;\n#endif\n#ifdef TEXTURES\n#if TEXTURES == 2\nin vec2 a_uv;\n#elif TEXTURES == 3\nin vec3 a_uv;\n#endif\n#endif\n#ifdef SKINNING\n#if SKINNING == 1\nin float a_index;\n#elif SKINNING == 2\nin vec2 a_index;\nin vec2 a_weight;\n#elif SKINNING == 3\nin vec3 a_index;\nin vec3 a_weight;\n#elif SKINNING == 4\nin vec4 a_index;\nin vec4 a_weight;\n#endif\n#endif\n#ifdef INSTANCE_POS\nin vec3 a_instanceTransform;\n#endif\n#ifdef INSTANCE_POS_SCALE\nin vec4 a_instanceTransform;\n#endif\n#ifdef INSTANCE_MATRIX\nin mat4 a_instanceTransform;\n#endif\n#ifdef INSTANCE_COLOR\nin vec4 a_instanceColor;\n#endif\n#ifdef INSTANCE_UV\nin vec2 a_instanceUV;\n#endif\n#ifdef INSTANCE_UVS\nin vec4 a_instanceUV;\n#endif\n\nINTERPOLATION out vec4 v_color;\n#ifdef TEXTURES\n#if TEXTURES == 2\nINTERPOLATION out vec2 v_uv;\n#elif TEXTURES == 3\nINTERPOLATION out vec3 v_uv;\n#endif\n#endif\nINTERPOLATION out vec3 v_viewpos;\n\nuniform mat4 u_projection;\nuniform mat4 u_view;\nuniform mat4 u_model;\n#ifdef BONE_COUNT\nuniform mat4 u_bones[BONE_COUNT];\n#endif\nuniform vec2 u_uvOffset;\nuniform vec3 u_fog_position;\n\nvoid main() {\n  vec4 pos = a_position;\n#ifdef SKINNING\n#if SKINNING == 1\n  pos = u_bones[int(a_index)] * a_position;\n#elif SKINNING == 2\n  pos = u_bones[int(a_index.x)] * a_position * a_weight.x +\n        u_bones[int(a_index.y)] * a_position * a_weight.y;\n#elif SKINNING == 3\n  pos = u_bones[int(a_index.x)] * a_position * a_weight.x +\n        u_bones[int(a_index.y)] * a_position * a_weight.y +\n        u_bones[int(a_index.z)] * a_position * a_weight.z;\n#elif SKINNING == 4\n  pos = u_bones[int(a_index.x)] * a_position * a_weight.x +\n        u_bones[int(a_index.y)] * a_position * a_weight.y +\n        u_bones[int(a_index.z)] * a_position * a_weight.z +\n        u_bones[int(a_index.w)] * a_position * a_weight.w;\n#endif\n#endif\n#ifdef FOG_IN_MODEL_SPACE\n  v_viewpos = pos.xyz;\n#endif\n#ifdef INSTANCING\n  pos = u_model * pos;\n#endif\n#ifdef INSTANCE_POS_SCALE\n  pos.xyz *= a_instanceTransform.w;\n#endif\n#ifdef BILLBOARD\n  vec4 pos2 = pos;\n  pos = vec4(0,0,0,1);\n#endif\n#if defined(INSTANCE_POS) || defined(INSTANCE_POS_SCALE)\n  pos.xyz += a_instanceTransform.xyz;\n#endif\n#ifdef INSTANCE_MATRIX\n  pos = a_instanceTransform * pos;\n#endif\n#ifndef INSTANCING\n  pos = u_model * pos;\n#endif\n  vec4 view = u_view * pos;\n#ifdef BILLBOARD\n#ifdef INSTANCE_MATRIX\n  pos2 = a_instanceTransform * vec4(pos2.xyz, 0);\n#endif\n#ifndef INSTANCING\n  pos2 = u_model * vec4(pos2.xyz, 0);\n#endif\n  view += pos2;\n#ifdef FOG_IN_WORLD_SPACE\n  v_viewpos = vec4(inverse(u_view) * view).xyz;\n#endif\n#else\n#ifdef FOG_IN_WORLD_SPACE\n  v_viewpos = pos.xyz;\n#endif\n#endif\n#ifdef TEXTURES\n#if TEXTURES == 2\n  vec2 uv = a_uv;\n#ifdef INSTANCE_UVS\n  uv *= a_instanceUV.zw;\n  uv += a_instanceUV.xy;\n#endif\n#ifdef INSTANCE_UV\n  uv += a_instanceUV.xy;\n#endif\n#ifdef UV_OFFSET\n  uv += u_uvOffset;\n#endif\n#elif TEXTURES == 3\n  vec3 uv = a_uv;\n#endif\n#endif\n  gl_Position = u_projection * view;\n#ifdef COLORS\n  vec4 color = a_color;\n#else\n  vec4 color = vec4(1);\n#endif\n#ifdef INSTANCE_COLOR\n  color *= a_instanceColor;\n#endif\n  v_color = color;\n#ifdef TEXTURES\n  v_uv = uv;\n#endif\n#ifdef FOG_IN_VIEW_SPACE\n  v_viewpos = view.xyz;\n#endif\n#ifdef FOG_POS\n  v_viewpos -= u_fog_position;\n#endif\n}\n",m="\n#ifdef MSAA_CENTROID\n#define INTERPOLATION centroid\n#endif\n#ifdef MSAA_SAMPLE\n#extension GL_OES_shader_multisample_interpolation : require\n#define INTERPOLATION sample\n#endif\n#ifndef INTERPOLATION\n#define INTERPOLATION\n#endif\n\nprecision mediump float;\n\nINTERPOLATION in vec4 v_color;\n#ifdef TEXTURES\n#if TEXTURES == 2\nINTERPOLATION in vec2 v_uv;\n#elif TEXTURES == 3\nINTERPOLATION in vec3 v_uv;\n#endif\n#endif\nINTERPOLATION in vec3 v_viewpos;\n\nout vec4 outColor;\n\n#ifdef TEXTURES\n#if TEXTURES == 2\nuniform sampler2D u_texture;\n#elif TEXTURES == 3\nuniform samplerCube u_texture;\n#endif\n#endif\nuniform vec4 u_color_mul;\nuniform vec4 u_color_add;\nuniform vec3 u_fog_color;\nuniform vec2 u_fog_dist;\nuniform float u_alpha_threshold;\n\nvoid main() {\n#ifdef TEXTURES\n  vec4 color = texture(u_texture, v_uv);\n  color.rgb /= color.a;\n#else\n  vec4 color = vec4(1);\n#endif\n#if defined(COLORS) || defined(INSTANCE_COLOR)\n  color = color * v_color;\n#endif\n#ifdef ALPHATEST\n  if (color.a <= u_alpha_threshold) discard;\n#endif\n#ifdef MAKE_OPAQUE\n  color.a = 1.0;\n#endif\n  color = color * u_color_mul + u_color_add;\n#ifdef FOG\n  float fog = (length(v_viewpos) - u_fog_dist.x) / u_fog_dist.y;\n  color.rgb = mix(color.rgb, u_fog_color, clamp(fog, 0.0, 1.0));\n#endif\n  color.a = clamp(color.a, 0.0, 1.0);\n  color.rgb *= color.a;\n  outColor = color;\n}\n";function h(e,t,r,n=1){const a=t.map((t=>e.lookupVariableByNameAndType(t,"list")));if(a.includes(null))return null;const o=a[0].value.length,s=a.length;if(a.find((e=>e.value.length!==o)))return null;const i=new r(o*s);if(1!==n)if(1==s){const e=a[0].value;for(let t=0;t<o;t++)i[t]=e[t]*n}else if(2==s){const e=a[0].value,t=a[1].value;for(let r=0,a=0;r<o;r++,a+=2)i[a]=e[r]*n,i[a+1]=t[r]*n}else if(3==s){const e=a[0].value,t=a[1].value,r=a[2].value;for(let a=0,s=0;a<o;a++,s+=3)i[s]=e[a]*n,i[s+1]=t[a]*n,i[s+2]=r[a]*n}else if(4==s){const e=a[0].value,t=a[1].value,r=a[2].value,s=a[3].value;for(let a=0,l=0;a<o;a++,l+=4)i[l]=e[a]*n,i[l+1]=t[a]*n,i[l+2]=r[a]*n,i[l+3]=s[a]*n}else for(let e=0,t=0;e<o;e++)for(let r=0;r<s;r++)i[t++]=a[r].value[e]*n;else if(1==s){const e=a[0].value;for(let t=0;t<o;t++)i[t]=+e[t]}else if(2==s){const e=a[0].value,t=a[1].value;for(let r=0,n=0;r<o;r++,n+=2)i[n]=+e[r],i[n+1]=+t[r]}else if(3==s){const e=a[0].value,t=a[1].value,r=a[2].value;for(let n=0,a=0;n<o;n++,a+=3)i[a]=+e[n],i[a+1]=+t[n],i[a+2]=+r[n]}else if(4==s){const e=a[0].value,t=a[1].value,r=a[2].value,n=a[3].value;for(let a=0,s=0;a<o;a++,s+=4)i[s]=+e[a],i[s+1]=+t[a],i[s+2]=+r[a],i[s+3]=+n[a]}else for(let e=0,t=0;e<o;e++)for(let r=0;r<s;r++)i[t++]=+a[r].value[e];return i}function T(e,t,r,a,o,s=_.ARRAY_BUFFER){if(e&&r&&r.length%a==0)if(e.uploadOffset<0){const i=e.myBuffers[t]??(e.myBuffers[t]=new n(o));_.bindBuffer(s,i.buffer),_.bufferData(s,r,e.uploadUsage),i.size=a,i.length=r.length/a,i.bytesPerEl=r.BYTES_PER_ELEMENT,e.update()}else{const n=e.myBuffers[t];if(!n||n.size!==a||e.uploadOffset*a+r.length>n.length*a)return;_.bindBuffer(s,n.buffer),_.bufferSubData(s,e.uploadOffset*a*r.BYTES_PER_ELEMENT,r)}}function E(e,t){const r=[];for(let n=0;n<e.length;n+=t)r.push(e.slice(n,n+t));return r}if(!e.extensions.unsandboxed)throw new Error("Simple 3D extension must be run unsandboxed");const N=e.ArgumentType,R=e.BlockType,A=e.Cast,g=e.vm,b=g.renderer,y=g.runtime,S="xeltallivSimple3D";let x=!0,M=document.createElement("canvas"),_=M.getContext("webgl2");_||alert("Simple 3D extension failed to get WebGL2 context. If it worked before, try restarting your browser or rebooting your device. If not, your GPU might not support WebGL2");const I=_.getExtension("EXT_texture_filter_anisotropic")||_.getExtension("MOZ_EXT_texture_filter_anisotropic")||_.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),O=_.getExtension("OES_shader_multisample_interpolation");_.enable(_.DEPTH_TEST),_.pixelStorei(_.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0);const v={"overwrite color (fastest for opaque)":[!1],default:[!0,_.ONE,_.ONE_MINUS_SRC_ALPHA,_.ONE,_.ONE_MINUS_SRC_ALPHA,_.FUNC_ADD],"default behind":[!0,_.ONE_MINUS_DST_ALPHA,_.ONE,_.ONE_MINUS_DST_ALPHA,_.ONE,_.FUNC_ADD],additive:[!0,_.ONE,_.ONE,_.ZERO,_.ONE,_.FUNC_ADD],subtractive:[!0,_.ONE,_.ONE,_.ZERO,_.ONE,_.FUNC_REVERSE_SUBTRACT],multiply:[!0,_.DST_COLOR,_.ONE_MINUS_SRC_ALPHA,_.DST_COLOR,_.ONE_MINUS_SRC_ALPHA,_.FUNC_ADD],invert:[!0,_.ONE_MINUS_DST_COLOR,_.ONE_MINUS_SRC_COLOR,_.ZERO,_.ONE,_.FUNC_ADD],invisible:[!0,_.ZERO,_.ONE,_.ZERO,_.ONE,_.FUNC_ADD],mask:[!0,_.ZERO,_.SRC_ALPHA,_.ZERO,_.SRC_ALPHA,_.FUNC_ADD],erase:[!0,_.ZERO,_.ONE_MINUS_SRC_ALPHA,_.ZERO,_.ONE_MINUS_SRC_ALPHA,_.FUNC_ADD]},D={nothing:[!1],"back faces":[!0,_.BACK],"front faces":[!0,_.FRONT]},U={nothing:_.NEVER,closer:_.LESS,same:_.EQUAL,further:_.GREATER,"closer or same":_.LEQUAL,"further or same":_.GEQUAL,"not same":_.NOTEQUAL,everything:_.ALWAYS},C={points:_.POINTS,lines:_.LINES,"line loop":_.LINE_LOOP,"line strip":_.LINE_STRIP,triangles:_.TRIANGLES,"triangle strip":_.TRIANGLE_STRIP,"triangle fan":_.TRIANGLE_FAN},P={color:_.COLOR_BUFFER_BIT,depth:_.DEPTH_BUFFER_BIT,"color and depth":_.COLOR_BUFFER_BIT|_.DEPTH_BUFFER_BIT},w=function(){const e=_.createTexture();_.bindTexture(_.TEXTURE_2D,e),_.texParameteri(_.TEXTURE_2D,_.TEXTURE_WRAP_S,_.REPEAT),_.texParameteri(_.TEXTURE_2D,_.TEXTURE_WRAP_T,_.REPEAT),_.texParameteri(_.TEXTURE_2D,_.TEXTURE_MIN_FILTER,_.NEAREST),_.texParameteri(_.TEXTURE_2D,_.TEXTURE_MAG_FILTER,_.NEAREST);const t=new Image;return t.src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAABg2lDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw1AUhU9TpUUqDnYQcchQneyiIo61FYpQIdQKrTqYvPQPmjQkKS6OgmvBwZ/FqoOLs64OroIg+APi7OCk6CIl3pcUWsT44PI+znvncN99gNCqMc3qSwCabpvZdFLMF1bF0CsEhAGqmMwsY16SMvBdX/cI8P0uzrP87/25BtWixYCASJxghmkTbxDPbtoG533iKKvIKvE58aRJDRI/cl3x+I1z2WWBZ0bNXDZFHCUWyz2s9DCrmBrxDHFM1XTKF/Ieq5y3OGu1Buv0yV8YKeory1ynGkMai1iCBBEKGqiiBhtx2nVSLGTpPOnjH3X9ErkUclXByLGAOjTIrh/8D37P1ipNT3lJkSTQ/+I4H+NAaBdoNx3n+9hx2idA8Bm40rv+eguY+yS92dViR8DQNnBx3dWUPeByBxh5MmRTdqUglVAqAe9n9E0FYPgWGFjz5tY5x+kDkKNZZW6Ag0NgokzZ6z7vDvfO7d87nfn9ACRZcoedT/mXAAAAGFBMVEVtbW11dXVtbf+EhIT/bW2goKBt/21t//8Qh6V7AAAACXBIWXMAABhMAAAYdAGfqEAgAAAAB3RJTUUH6AIIAA4YBFj9GAAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAABjSURBVAjXPctBDkAwFIThqdey91ygnIAoa9EzcIBGLyDS69MW/26+ZIAvZYwhZkbpNy/saKGOyUjmFeQ2J5Z+SUJNFi+TfK+/uKJCtENbhT2gYO7UNT+ie03nfoLqV4os4X/dFf0TKILDS0AAAAAASUVORK5CYII=",t.onload=function(){_.bindTexture(_.TEXTURE_2D,e),_.texImage2D(_.TEXTURE_2D,0,_.RGBA,_.RGBA,_.UNSIGNED_BYTE,t)},e}(),B=new Map,L=new class{constructor(){this.programs={}}get(e){const t=e.join("-");let r=this.programs[t];return r||(r=function(e){console.log("Compiling program with flags:",e);const t="#version 300 es\n"+e.map((e=>`#define ${e}\n`)).join(""),r=_.createShader(_.VERTEX_SHADER),n=_.createShader(_.FRAGMENT_SHADER);_.shaderSource(r,t+p),_.shaderSource(n,t+m),_.compileShader(r),_.compileShader(n);const a=_.createProgram();_.attachShader(a,r),_.attachShader(a,n),_.linkProgram(a);const o=_.getProgramParameter(a,_.LINK_STATUS);if(o||(console.log("Shader error:"),console.log(_.getShaderInfoLog(r)),console.log(_.getShaderInfoLog(n)),console.log(_.getProgramInfoLog(a))),_.deleteShader(r),_.deleteShader(n),!o)return _.deleteProgram(a),{};_.useProgram(a);const s={},i=_.getProgramParameter(a,_.ACTIVE_ATTRIBUTES);for(let e=0;e<i;e++){const t=_.getActiveAttrib(a,e);s[t.name.split("[")[0]]=_.getAttribLocation(a,t.name)}const l={},u=_.getProgramParameter(a,_.ACTIVE_UNIFORMS);for(let e=0;e<u;e++){const t=_.getActiveUniform(a,e);l[t.name.split("[")[0]]=_.getUniformLocation(a,t.name)}return{program:a,aloc:s,uloc:l}}(e),this.programs[t]=r,r)}clear(){for(const e in this.programs)this.programs[e].program&&_.deleteProgram(this.programs[e].program);this.programs={}}},V=new class{constructor(){this.worker=null,this.timeout=-1,this.resolveFn=null,this.queue=[],this.timeLimit=9e4,this.boundHandle=this.handle.bind(this)}decode(e,t,r){return new Promise((n=>{this.queue.push({data:{type:e,array:t,importMatrix:r},resolve:n}),this.tryMoveQueue()}))}tryMoveQueue(){if(this.busy)return;if(0==this.queue.length)return;this.worker||(this.worker=new Worker(`data:text/javascript;base64,${btoa(d)}`),this.worker.addEventListener("message",this.boundHandle));const{data:e,resolve:t}=this.queue.shift();this.resolveFn=t,this.busy=!0,this.worker.postMessage(e),this.timeout=setTimeout(this.restartWorker.bind(this),this.timeLimit)}handle(e){-1!==this.timeout&&(clearTimeout(this.timeout),this.timeout=-1),this.resolveFn(e.data),this.resolveFn=null,this.busy=!1,this.tryMoveQueue()}clear(){for(const{resolve:e}of this.queue)e(null);this.queue=[]}destroy(){this.clear(),this.destroyWorker()}destroyWorker(){this.resolveFn&&(this.resolveFn(null),this.resolveFn=null),this.worker&&(this.worker.removeEventListener("message",this.boundHandle),this.worker.terminate(),this.worker=null,this.busy=!1)}restartWorker(){console.warn("Simple3D: Worker took too long to decode the model and was terminated"),this.destroyWorker(),this.tryMoveQueue()}},G=y.ext_xeltallivSimple3Dapi??(y.ext_xeltallivSimple3Dapi={}),F=G.externalTransforms??(G.externalTransforms={}),k=new class extends a{constructor(){super(),this.reset()}get width(){return M.width}get height(){return M.height}getFramebuffer(){return null}getMesh(){return null}setDepth(e,t){this.depthTest=e,this.depthWrite=t}get hasDepthBuffer(){return!0}isLoading(){return!1}checkIfValid(){return!0}reset(){this.depthTest="closer",this.depthWrite=!0}};let X,Y,z,W,H,Z,j,K,q,Q,$,J,ee,te,re,ne,ae,oe,se,ie=null,le=null;function ue(){_.clearColor(0,0,0,0),_.clear(_.COLOR_BUFFER_BIT|_.DEPTH_BUFFER_BIT),k.reset(),k.setAsRenderTarget(),Y={modelToWorld:t.identity(),worldToView:t.identity(),viewToProjected:t.identity(),import:t.identity(),custom:t.identity()},z=[0,0,0,0],W="viewToProjected",H=[1,1,1,1],Z=[0,0,0,0],j=[1,1,1],K=[10,90],q=!1,Q=null,$="view space",J=null,ee=null,te="unset",re=[null,null,null,null,null,null],ne=0,ae=[null,null],oe=null,se={from:t.identity(),to:t.identity(),matrix:t.identity()};for(const e of B.values())e.destroy();B.clear(),L.clear(),V.clear(),x=!0,b.dirty=!0,y.requestRedraw()}ue(),function(e){let t=b._groupOrdering.indexOf("video");b._groupOrdering.splice(t+1,0,"simple3D"),b._layerGroups.simple3D={groupIndex:0,drawListOffset:b._layerGroups.video.drawListOffset};for(let e=0;e<b._groupOrdering.length;e++)b._layerGroups[b._groupOrdering[e]].groupIndex=e;le=b._nextSkinId++;const r=new c(le,b);b._allSkins[le]=r,ie=b.createDrawable("simple3D");const n=b._allDrawables[ie];if(b.updateDrawableSkinId(ie,le),b.markDrawableAsNoninteractive&&b.markDrawableAsNoninteractive(ie),n.setHighQuality=function(...e){Object.getPrototypeOf(this).setHighQuality(...e),this.skin.resizeCanvas()},n.customDrawableName="Simple3D Layer",!e.redraw){const t=b.draw;b.draw=function(){this.dirty&&e.redraw&&e.redraw(),t.call(this)}}e.redraw=function(){x&&(r.updateContent(M),x=!1)},e.redraw()}(G),y.on("PROJECT_LOADED",ue);const fe=[{blockType:R.BUTTON,text:"Open extra resources",func:"openSite",def:function(){window.open("https://xeltalliv.github.io/simple3d-extension/")}},{blockType:R.BUTTON,text:"Open sample project",func:"getSampleProject",def:function(){const e=new URL(location.href);e.searchParams.set("project_url","https://extensions.turbowarp.org/samples/Simple3D%20template.sb3"),window.open(e.href)}},{blockType:R.LABEL,text:"Clearing"},{opcode:"resetEverything",blockType:R.COMMAND,text:"reset everything",def:function(){ue()}},"---",{opcode:"clear",blockType:R.COMMAND,text:"clear [LAYERS]",arguments:{LAYERS:{type:N.STRING,menu:"clearLayers",defaultValue:"color and depth"}},def:function({LAYERS:e}){r(P,e)&&(_.getParameter(_.DEPTH_WRITEMASK)?_.clear(P[e]):(_.depthMask(!0),_.clear(P[e]),_.depthMask(!1)),X===k&&(x=!0,b.dirty=!0,y.requestRedraw()))}},{opcode:"clearColor",blockType:R.COMMAND,text:"set clear color R: [RED] G: [GREEN] B: [BLUE] A: [ALPHA]",arguments:{RED:{type:N.NUMBER,defaultValue:.5},GREEN:{type:N.NUMBER,defaultValue:.5},BLUE:{type:N.NUMBER,defaultValue:.5},ALPHA:{type:N.NUMBER,defaultValue:1}},def:function({RED:e,GREEN:t,BLUE:r,ALPHA:n}){const a=A.toNumber(n);_.clearColor(A.toNumber(e)*a,A.toNumber(t)*a,A.toNumber(r)*a,a)}},{opcode:"depth",blockType:R.COMMAND,text:"depth test [TEST] write [WRITE]",arguments:{TEST:{type:N.STRING,defaultValue:"closer",menu:"depthTest"},WRITE:{type:N.STRING,defaultValue:"true",menu:"onOff"}},def:function({TEST:e,WRITE:t}){let n=A.toString(e);r(U,n)&&(X.setDepth(n,A.toBoolean(t)),X.updateDepth())}},{blockType:R.LABEL,text:"Meshes"},{opcode:"allMeshes",blockType:R.REPORTER,text:"all meshes",disableMonitor:!0,def:function(){return Array.from(B.keys()).join(",")}},{opcode:"createMesh",blockType:R.COMMAND,text:"create mesh [NAME]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"}},def:function({NAME:e}){0!=(e=A.toString(e).replace(/,/g,"").trim()).length&&(B.get(e)?.destroy(),B.set(e,new u(e)))}},{opcode:"deleteMesh",blockType:R.COMMAND,text:"delete mesh [NAME]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"}},def:function({NAME:e}){e=A.toString(e),B.get(e)?.destroy(),B.delete(e)}},{opcode:"inheritMeshes",blockType:R.COMMAND,text:"make [NAME] inherit from meshes [NAMES]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh 3"},NAMES:{type:N.STRING,defaultValue:"my mesh 1,my mesh 2"}},def:function({NAME:e,NAMES:t}){const r=B.get(A.toString(e));if(!r)return;const n=A.toString(t).split(",").map((e=>B.get(e.trim()))).filter((e=>e));for(let e of n)if(e.dependsOn(r))return;for(let e of r.dependencies)e.dependants.delete(r);r.dependencies=new Set(n);for(let e of n)e.dependants.add(r);r.update()}},{opcode:"meshInfo",blockType:R.REPORTER,text:"mesh [NAME] [PROP]",allowDropAnywhere:!0,arguments:{PROP:{type:N.STRING,menu:"meshProperties",defaultValue:"inherits from"},NAME:{type:N.STRING,defaultValue:"my mesh"}},def:function({NAME:e,PROP:t}){const n=B.get(A.toString(e));return"exists"==t?!!n:n&&r(f,t)?f[t](n)??"":""}},"---",{opcode:"setMeshIndices",blockType:R.COMMAND,text:"set [NAME] vertex indices [INDICES]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},INDICES:{type:N.STRING,menu:"lists"}},def:function({NAME:e,INDICES:t},{target:r}){const n=B.get(A.toString(e)),a=function(e,t){const r=e.lookupVariableByNameAndType(t,"list");if(!r)return null;let n,a,o=0,s=[],i=[];for(let e=0;e<r.value.length;e++){let t=Math.floor(A.toNumber(r.value[e])-1);t<0?i.push(e):t>o&&(o=t),s.push(t)}o>4294967294&&alert(`Simple3D error: Found vertex index ${o}. The maximum supported value is 4294967295.`),o>65534?(a=Uint32Array,n=4294967295):o>254?(a=Uint16Array,n=65535):(a=Uint8Array,n=255);for(let e of i)s[e]=n;return new a(s)}(r,t);n&&a&&T(n,"indices",a,1,-1,_.ELEMENT_ARRAY_BUFFER)}},{opcode:"setMeshPositionsXY",blockType:R.COMMAND,text:"set [NAME] positions XY [X] [Y]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},X:{type:N.STRING,menu:"lists"},Y:{type:N.STRING,menu:"lists"},Z:{type:N.STRING,menu:"lists"}},def:function({NAME:e,X:t,Y:r},{target:n}){T(B.get(A.toString(e)),"position",h(n,[t,r],Float32Array),2,0)}},{opcode:"setMeshPositionsXYZ",blockType:R.COMMAND,text:"set [NAME] positions XYZ [X] [Y] [Z]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},X:{type:N.STRING,menu:"lists"},Y:{type:N.STRING,menu:"lists"},Z:{type:N.STRING,menu:"lists"}},def:function({NAME:e,X:t,Y:r,Z:n},{target:a}){T(B.get(A.toString(e)),"position",h(a,[t,r,n],Float32Array),3,0)}},{opcode:"setMeshColorsRGB",blockType:R.COMMAND,text:"set [NAME] colors RGB [R] [G] [B]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},R:{type:N.STRING,menu:"lists"},G:{type:N.STRING,menu:"lists"},B:{type:N.STRING,menu:"lists"}},def:function({NAME:e,R:t,G:r,B:n},{target:a}){T(B.get(A.toString(e)),"colors",h(a,[t,r,n],Uint8Array),3,0)}},{opcode:"setMeshColorsRGBA",blockType:R.COMMAND,text:"set [NAME] colors RGBA [R] [G] [B] [A]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},R:{type:N.STRING,menu:"lists"},G:{type:N.STRING,menu:"lists"},B:{type:N.STRING,menu:"lists"},A:{type:N.STRING,menu:"lists"}},def:function({NAME:e,R:t,G:r,B:n,A:a},{target:o}){T(B.get(A.toString(e)),"colors",h(o,[t,r,n,a],Uint8Array),4,0)}},{opcode:"setMeshTexCoordUV",blockType:R.COMMAND,text:"set [NAME] texture coordinates UV [U] [V]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},U:{type:N.STRING,menu:"lists"},V:{type:N.STRING,menu:"lists"}},def:function({NAME:e,U:t,V:r},{target:n}){const a=B.get(A.toString(e)),o=h(n,[t,r],Float32Array);a&&o&&T(a,"texCoords",o,2,0)}},{opcode:"setMeshTexture",blockType:R.COMMAND,text:"set [NAME] texture [TEXTURE] [WRAP] [FILTER]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},TEXTURE:{type:null},WRAP:{type:N.STRING,menu:"textureWrap"},FILTER:{type:N.STRING,menu:"textureFilter"}},def:function({NAME:e,TEXTURE:t,WRAP:r,FILTER:n},{target:a}){const o=B.get(A.toString(e));if(!o)return;if("[texture data]"!==A.toString(t))return;const i="repeat"==A.toString(r)?_.REPEAT:_.CLAMP_TO_EDGE,l="blurred"==A.toString(n)?_.LINEAR:_.NEAREST;let u=o.myData.texture??(o.myData.texture=new s(o));if(!(u instanceof s))return;u.main.loading=!0,u.main.failedToLoad=!1,o.update();const f=function(e){if(null==e||o.destroyed)return u.main.loading=!1,void(u.main.failedToLoad=!0);u.main.setTexture(e.data,e.width,e.height,i,l)};ee?f(ee):J.then(f)}},{opcode:"setMeshTexCoordUVW",blockType:R.COMMAND,text:"set [NAME] cube texture coordinates UVW [U] [V] [W]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},U:{type:N.STRING,menu:"lists"},V:{type:N.STRING,menu:"lists"},W:{type:N.STRING,menu:"lists"}},def:function({NAME:e,U:t,V:r,W:n},{target:a}){T(B.get(A.toString(e)),"texCoords",h(a,[t,r,n],Float32Array),3,0)}},{opcode:"setMeshCubeTexture",blockType:R.COMMAND,text:"set [NAME] cube texture [SIDE] [TEXTURE] [WRAP] [FILTER]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},SIDE:{type:N.STRING,menu:"cubeSide"},TEXTURE:{type:null},WRAP:{type:N.STRING,menu:"textureWrap"},FILTER:{type:N.STRING,menu:"textureFilter"}},def:function({NAME:e,SIDE:t,TEXTURE:n,WRAP:a,FILTER:o},{target:s}){const l=B.get(A.toString(e));if(!l)return;if("[texture data]"!==A.toString(n))return;const u="repeat"==A.toString(a)?_.REPEAT:_.CLAMP_TO_EDGE,f="blurred"==A.toString(o)?_.LINEAR:_.NEAREST;let d=l.myData.texture??(l.myData.texture=new i(l));if(!(d instanceof i))return;const c={"X+":"xpos","X-":"xneg","Y+":"ypos","Y-":"yneg","Z+":"zpos","Z-":"zneg"};if(!r(c,t))return;d[c[t]].loading=!0,d[c[t]].failedToLoad=!1,l.update();const p=function(e){if(null==e||l.destroyed)return d[c[t]].loading=!1,void(d[c[t]].failedToLoad=!0);d[c[t]].setTexture(e.data,e.width,e.height,u,f)};ee?p(ee):J.then(p)}},{opcode:"setMeshTextureMipmap",blockType:R.COMMAND,text:"set [NAME] texture mipmapping [MIPMAPPING]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},MIPMAPPING:{type:N.STRING,menu:"textureMipmapping"}},def:function({NAME:e,MIPMAPPING:t},{target:r}){const n=B.get(A.toString(e));if(!n)return;const a=n.myData.texture;a&&("off"==t&&a.setMipmapState(!1,_.NEAREST),"sharp transitions"==t&&a.setMipmapState(!0,_.NEAREST),"smooth transitions"==t&&a.setMipmapState(!0,_.LINEAR))}},{opcode:"setMeshTextureAnisotropy",blockType:R.COMMAND,text:"set [NAME] texture anisotropic filtering [ANISOTROPY]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},ANISOTROPY:{type:N.STRING,menu:"powersOfTwo",defaultValue:16}},def:function({NAME:e,ANISOTROPY:t},{target:r}){const n=B.get(A.toString(e));if(!n)return;const a=n.myData.texture;a&&a.setAnisotropy(Math.max(1,Math.round(A.toNumber(t))))}},{opcode:"setMeshWeights",blockType:R.COMMAND,text:"set [NAME] bone indices [INDICES] weights [WEIGHTS] count per vertex [COUNT]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},INDICES:{type:N.STRING,menu:"lists"},WEIGHTS:{type:N.STRING,menu:"lists"},COUNT:{type:N.NUMBER,defaultValue:3}},def:function({NAME:e,INDICES:t,WEIGHTS:r,COUNT:n},{target:a}){if((n=Math.floor(A.toNumber(n)))<1||n>4)return;const o=B.get(A.toString(e));let s,i=h(a,[t],Uint8Array);!o||!i||i.length%n>0||n>1&&(s=h(a,[r],Uint16Array,65535),!s||s.length%n>0||s.length!==i.length)||(T(o,"boneIndices",i,n,0),n>1&&T(o,"boneWeights",s,n,0))}},{opcode:"setMeshTransforms",blockType:R.COMMAND,text:"set [NAME] [TRANSFORMS] transforms [MATRIXES]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},TRANSFORMS:{type:N.STRING,menu:"skinningTransforms"},MATRIXES:{type:N.STRING,menu:"lists"}},def:function({NAME:e,TRANSFORMS:r,MATRIXES:n},{target:a}){const o=B.get(A.toString(e)),s=o.myData,i=a.lookupVariableByNameAndType(A.toString(n),"list");if(!o||!i)return;const l=i.value.map(A.toNumber);if("original"==r&&(s.bonesOrig=E(l,16).map(t.inverse),s.bonesCurr||(s.bonesCurrRaw?(s.bonesCurr=E(s.bonesCurrRaw,16),s.bonesCurrRaw=null):s.bonesCurr=E(l,16))),"current"==r&&(s.bonesOrig?(s.bonesCurr=E(l,16),s.bonesCurrRaw=null):s.bonesCurrRaw=l),s.bonesOrig){const e=[],r=Math.min(s.bonesCurr.length,s.bonesOrig.length);let n=0;for(;n<r;n++)e.push(t.multiply(s.bonesCurr[n],s.bonesOrig[n]));for(;n<s.bonesCurr.length;n++)e.push(s.bonesCurr[n]);s.bonesDiff=e.flat()}else s.bonesDiff=s.bonesCurrRaw;o.update()}},{opcode:"setMeshInterleaved",blockType:R.COMMAND,text:"set [NAME] interleaved [PROPERTY] [SRCLIST]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},PROPERTY:{type:N.STRING,menu:"interleavedProperty"},SRCLIST:{type:N.STRING,menu:"lists"}},def:function({NAME:e,PROPERTY:t,SRCLIST:r},{target:n}){let a,o,s;if("XY positions"==t&&(a="position",o=2,s=Float32Array),"XYZ positions"==t&&(a="position",o=3,s=Float32Array),"RGB colors"==t&&(a="colors",o=3,s=Uint8Array),"RGBA colors"==t&&(a="colors",o=4,s=Uint8Array),"UV texture coordinates"==t&&(a="texCoords",o=2,s=Float32Array),"UVW texture coordinates"==t&&(a="texCoords",o=3,s=Float32Array),!a)return;T(B.get(A.toString(e)),a,h(n,[r],s),o,0)}},{opcode:"setMeshInstances",blockType:R.COMMAND,text:"set [NAME] instance [PROPERTY] [SRCLIST]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},PROPERTY:{type:N.STRING,menu:"instanceProperty"},SRCLIST:{type:N.STRING,menu:"lists"}},def:function({NAME:e,PROPERTY:t,SRCLIST:r},{target:n}){let a,o,s;if("transforms"==t&&(a="instanceTransforms",o=16,s=Float32Array),"XY positions"==t&&(a="instanceTransforms",o=2,s=Float32Array),"XYZ positions"==t&&(a="instanceTransforms",o=3,s=Float32Array),"XYZ positions and sizes"==t&&(a="instanceTransforms",o=4,s=Float32Array),"RGB colors"==t&&(a="instanceColors",o=3,s=Float32Array),"RGBA colors"==t&&(a="instanceColors",o=4,s=Float32Array),"UV offsets"==t&&(a="instanceUVOffsets",o=2,s=Float32Array),"UV offsets and sizes"==t&&(a="instanceUVOffsets",o=4,s=Float32Array),!a)return;T(B.get(A.toString(e)),a,h(n,[r],s),o,1)}},{opcode:"setMeshUploadOffset",blockType:R.COMMAND,text:"set [NAME] list update offset [OFFSET]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},OFFSET:{type:N.NUMBER,defaultValue:1}},def:function({NAME:e,OFFSET:t},{target:r}){const n=B.get(A.toString(e));n&&(n.uploadOffset=A.toNumber(t)-1)}},{opcode:"setBufferUsageHint",text:"set [NAME] optimize next uploaded lists for being [USAGE] updated",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},USAGE:{type:N.STRING,menu:"bufferUsage",defaultValue:"rarely"}},def:function({NAME:e,USAGE:t}){const r=B.get(A.toString(e));r&&("rarely"==t&&(r.uploadUsage=_.STATIC_DRAW),"frequently fully"==t&&(r.uploadUsage=_.STREAM_DRAW),"frequently partially"==t&&(r.uploadUsage=_.DYNAMIC_DRAW))}},{opcode:"setMeshFromFile",blockType:R.COMMAND,text:"set [NAME] from [FILETYPE] [SRCLIST]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},FILETYPE:{type:N.STRING,menu:"filetype"},SRCLIST:{type:N.STRING,menu:"lists"}},def:function({NAME:e,FILETYPE:t,SRCLIST:r},{target:n}){!async function(){const a=B.get(A.toString(e)),o=n.lookupVariableByNameAndType(r,"list");if(!a||!o)return;let s=await V.decode(t,o.value.slice(),Y.import);if(s){if(s.xyz){T(a,"position",new Float32Array(s.xyz),3,0)}if(s.rgba){T(a,"colors",new Uint8Array(s.rgba),4,0)}if(s.uv){T(a,"texCoords",new Float32Array(s.uv),2,0)}}}()}},{opcode:"setMeshPrimitives",blockType:R.COMMAND,text:"set [NAME] primitives [PRIMITIVES]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},PRIMITIVES:{type:N.STRING,menu:"primitives"}},def:function({NAME:e,PRIMITIVES:t},{target:n}){const a=B.get(A.toString(e)),o=A.toString(t);a&&r(C,o)&&(a.myData.primitives=C[o],a.myData.primitivesName=o,a.update())}},{opcode:"setMeshBlending",blockType:R.COMMAND,text:"set [NAME] blending [BLENDING]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},BLENDING:{type:N.STRING,menu:"blending",defaultValue:"default"}},def:function({NAME:e,BLENDING:t},{target:n}){const a=B.get(A.toString(e)),o=A.toString(t);a&&r(v,o)&&(a.myData.blending=o,a.update())}},{opcode:"setMeshCulling",blockType:R.COMMAND,text:"set [NAME] cull [CULLING]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},CULLING:{type:N.STRING,menu:"culling"}},def:function({NAME:e,CULLING:t},{target:n}){const a=B.get(A.toString(e)),o=A.toString(t);a&&r(D,o)&&(a.myData.culling=o,a.update())}},{opcode:"setMeshAlphaTest",blockType:R.COMMAND,text:"set [NAME] discard pixels less opaque than [ALPHATEST], for those that pass [MAKEOPAQUE]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},ALPHATEST:{type:N.STRING,defaultValue:.5},MAKEOPAQUE:{type:N.STRING,menu:"alphaTestMode",defaultValue:"true"}},def:function({NAME:e,ALPHATEST:t,MAKEOPAQUE:r},{target:n}){const a=B.get(A.toString(e)),o=A.toNumber(t),s=A.toBoolean(r);a&&(a.myData.alphaTest=o,a.myData.makeOpaque=s,a.update())}},{opcode:"setMeshBillboarding",blockType:R.COMMAND,text:"set [NAME] billboarding [BILLBOARDING]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},BILLBOARDING:{type:N.STRING,menu:"onOff"}},def:function({NAME:e,BILLBOARDING:t},{target:r}){const n=B.get(A.toString(e)),a=A.toBoolean(t);n&&(n.myData.billboarding=a,n.update())}},{opcode:"setMeshCentroidInterpolation",blockType:R.COMMAND,text:"set [NAME] accurate interpolation [USECENTROID]",hideFromPalette:!0,arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},USECENTROID:{type:N.STRING,menu:"onOff"}},def:function({NAME:e,USECENTROID:t},{target:r}){const n=B.get(A.toString(e)),a=A.toBoolean(t);n&&(n.myData.interpolation=a?"MSAA_CENTROID":"",n.update())}},{opcode:"setMeshMultiSampleInterpolation",blockType:R.COMMAND,text:"set [NAME] compute color [MODE]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},MODE:{type:N.STRING,menu:"multiSampleInterpolation"}},def:function({NAME:e,MODE:t},{target:r}){const n=B.get(A.toString(e));n&&("once at pixel center"===t&&(n.myData.interpolation=""),"once at midpoint of covered samples"===t&&(n.myData.interpolation="MSAA_CENTROID"),"separately for each sample"===t&&O&&(n.myData.interpolation="MSAA_SAMPLE"),n.update())}},{opcode:"setMeshDrawRange",blockType:R.COMMAND,text:"set [NAME] vertex draw range from [START] to [END]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},START:{type:N.NUMBER,defaultValue:1},END:{type:N.NUMBER,defaultValue:6}},def:function({NAME:e,START:t,END:r},{target:n}){const a=B.get(A.toString(e)),o=Math.max(1,Math.floor(A.toNumber(t)))-1,s=Math.max(0,Math.floor(A.toNumber(r)));a&&(a.myData.drawRange=[o,Math.max(0,s-o)],a.update())}},{opcode:"setMeshInstanceLimit",blockType:R.COMMAND,text:"set [NAME] instance draw limit [END]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},END:{type:N.NUMBER,defaultValue:10}},def:function({NAME:e,END:t},{target:r}){const n=B.get(A.toString(e));let a=Math.floor(A.toNumber(t));a<1&&(a=1/0),n&&(n.myData.maxInstances=a,n.update())}},{opcode:"setMeshTexCoordOffsetUV",blockType:R.COMMAND,text:"set [NAME] texture coordinate offset UV [U] [V]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"},U:{type:N.NUMBER},V:{type:N.NUMBER}},def:function({NAME:e,U:t,V:r},{target:n}){const a=B.get(A.toString(e));a&&(a.myData.uvOffset=[A.toNumber(t),A.toNumber(r)],a.update())}},{opcode:"drawMesh",blockType:R.COMMAND,text:"draw mesh [NAME]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"}},def:function({NAME:e},t){e=A.toString(e);const r=B.get(e);if(!r)return;if(!X.checkIfValid())return;if(X.getMesh()==r)return;if(!r.buffers.position)return;let n=-1,a=-1;for(const e in r.buffers){const t=r.buffers[e];if(0==t.type){if(-1==n)n=t.length;else if(n!==t.length)return}else if(1==t.type)if(-1==a)a=t.length;else if(a!==t.length)return}if(-1==n)return;let o=[];r.buffers.colors&&o.push("COLORS"),r.buffers.texCoords&&o.push(`TEXTURES ${r.buffers.texCoords.size}`),q&&(o.push("FOG"),"view space"==$&&o.push("FOG_IN_VIEW_SPACE"),"world space"==$&&o.push("FOG_IN_WORLD_SPACE"),"model space"==$&&o.push("FOG_IN_MODEL_SPACE"),Q&&o.push("FOG_POS")),r.buffers.boneIndices&&r.data.bonesDiff&&(o.push(`SKINNING ${r.buffers.boneIndices.size}`),o.push("BONE_COUNT "+r.data.bonesDiff.length/16)),r.data.interpolation&&o.push(r.data.interpolation),r.data.alphaTest>0&&o.push("ALPHATEST"),r.data.makeOpaque&&o.push("MAKE_OPAQUE"),r.data.billboarding&&o.push("BILLBOARD"),r.data.uvOffset&&o.push("UV_OFFSET"),r.buffers.instanceTransforms&&(o.push("INSTANCING"),r.buffers.instanceTransforms.size<=3&&o.push("INSTANCE_POS"),4==r.buffers.instanceTransforms.size&&o.push("INSTANCE_POS_SCALE"),16==r.buffers.instanceTransforms.size&&o.push("INSTANCE_MATRIX")),r.buffers.instanceColors&&o.push("INSTANCE_COLOR"),r.buffers.instanceUVOffsets&&o.push(4==r.buffers.instanceUVOffsets.size?"INSTANCE_UVS":"INSTANCE_UV");const s=L.get(o);if(!s.program)return;_.useProgram(s.program),r.buffers.indices&&_.bindBuffer(_.ELEMENT_ARRAY_BUFFER,r.buffers.indices.buffer),_.bindBuffer(_.ARRAY_BUFFER,r.buffers.position.buffer),_.enableVertexAttribArray(s.aloc.a_position),_.vertexAttribPointer(s.aloc.a_position,r.buffers.position.size,_.FLOAT,!1,0,0),r.buffers.colors&&(_.bindBuffer(_.ARRAY_BUFFER,r.buffers.colors.buffer),_.enableVertexAttribArray(s.aloc.a_color),_.vertexAttribPointer(s.aloc.a_color,r.buffers.colors.size,_.UNSIGNED_BYTE,!0,0,0)),r.buffers.texCoords&&(_.bindBuffer(_.ARRAY_BUFFER,r.buffers.texCoords.buffer),_.enableVertexAttribArray(s.aloc.a_uv),_.vertexAttribPointer(s.aloc.a_uv,r.buffers.texCoords.size,_.FLOAT,!1,0,0)),r.buffers.boneIndices&&(_.bindBuffer(_.ARRAY_BUFFER,r.buffers.boneIndices.buffer),_.enableVertexAttribArray(s.aloc.a_index),_.vertexAttribPointer(s.aloc.a_index,r.buffers.boneIndices.size,_.BYTE,!1,0,0)),r.buffers.boneWeights&&(_.bindBuffer(_.ARRAY_BUFFER,r.buffers.boneWeights.buffer),_.enableVertexAttribArray(s.aloc.a_weight),_.vertexAttribPointer(s.aloc.a_weight,r.buffers.boneWeights.size,_.UNSIGNED_SHORT,!0,0,0)),r.buffers.instanceTransforms&&(_.bindBuffer(_.ARRAY_BUFFER,r.buffers.instanceTransforms.buffer),16==r.buffers.instanceTransforms.size?(_.enableVertexAttribArray(s.aloc.a_instanceTransform),_.enableVertexAttribArray(s.aloc.a_instanceTransform+1),_.enableVertexAttribArray(s.aloc.a_instanceTransform+2),_.enableVertexAttribArray(s.aloc.a_instanceTransform+3),_.vertexAttribPointer(s.aloc.a_instanceTransform,4,_.FLOAT,!1,64,0),_.vertexAttribPointer(s.aloc.a_instanceTransform+1,4,_.FLOAT,!1,64,16),_.vertexAttribPointer(s.aloc.a_instanceTransform+2,4,_.FLOAT,!1,64,32),_.vertexAttribPointer(s.aloc.a_instanceTransform+3,4,_.FLOAT,!1,64,48),_.vertexAttribDivisor(s.aloc.a_instanceTransform,1),_.vertexAttribDivisor(s.aloc.a_instanceTransform+1,1),_.vertexAttribDivisor(s.aloc.a_instanceTransform+2,1),_.vertexAttribDivisor(s.aloc.a_instanceTransform+3,1)):(_.enableVertexAttribArray(s.aloc.a_instanceTransform),_.vertexAttribPointer(s.aloc.a_instanceTransform,r.buffers.instanceTransforms.size,_.FLOAT,!1,0,0),_.vertexAttribDivisor(s.aloc.a_instanceTransform,1))),r.buffers.instanceColors&&(_.bindBuffer(_.ARRAY_BUFFER,r.buffers.instanceColors.buffer),_.enableVertexAttribArray(s.aloc.a_instanceColor),_.vertexAttribPointer(s.aloc.a_instanceColor,r.buffers.instanceColors.size,_.FLOAT,!1,0,0),_.vertexAttribDivisor(s.aloc.a_instanceColor,1)),r.buffers.instanceUVOffsets&&(_.bindBuffer(_.ARRAY_BUFFER,r.buffers.instanceUVOffsets.buffer),_.enableVertexAttribArray(s.aloc.a_instanceUV),_.vertexAttribPointer(s.aloc.a_instanceUV,r.buffers.instanceUVOffsets.size,_.FLOAT,!1,0,0),_.vertexAttribDivisor(s.aloc.a_instanceUV,1));const i=r.data.blending??"default";if(i!==te){te=i;const e=v[i];e[0]!==re[0]&&(e[0]?_.enable(_.BLEND):_.disable(_.BLEND),re[0]=e[0]),e[0]&&(_.blendFuncSeparate(e[1],e[2],e[3],e[4]),e[5]!==re[5]&&(_.blendEquation(e[5]),re[5]=e[5]))}const l=r.data.culling??"nothing";if(l!==ne){ne=l;const e=D[l];e[0]!==ae[0]&&(e[0]?_.enable(_.CULL_FACE):_.disable(_.CULL_FACE),ae[0]=e[0]),e[0]&&e[1]!==ae[1]&&(_.cullFace(e[1]),ae[1]=e[1])}r.buffers.texCoords&&(_.activeTexture(_.TEXTURE0),_.bindTexture(r.data.texture?.target??_.TEXTURE_2D,r.data.texture?.texture??w),_.uniform1i(s.uloc.u_texture,0)),_.uniform4fv(s.uloc.u_color_mul,H),_.uniform4fv(s.uloc.u_color_add,Z),q&&(_.uniform3fv(s.uloc.u_fog_color,j),_.uniform2fv(s.uloc.u_fog_dist,K),Q&&_.uniform3fv(s.uloc.u_fog_position,Q)),r.data.alphaTest>0&&_.uniform1f(s.uloc.u_alpha_threshold,r.data.alphaTest),r.data.bonesDiff&&_.uniformMatrix4fv(s.uloc.u_bones,!1,r.data.bonesDiff),r.data.uvOffset&&_.uniform2fv(s.uloc.u_uvOffset,r.data.uvOffset),_.uniformMatrix4fv(s.uloc.u_projection,!1,Y.viewToProjected),_.uniformMatrix4fv(s.uloc.u_view,!1,Y.worldToView),_.uniformMatrix4fv(s.uloc.u_model,!1,Y.modelToWorld);let u=0,f=r.buffers.indices?r.buffers.indices.length:n;if(r.data.drawRange){const e=r.buffers.indices?r.buffers.indices.bytesPerEl:1;u=r.data.drawRange[0]*e;f=Math.min(r.data.drawRange[0]+r.data.drawRange[1],f)-r.data.drawRange[0]}if(r.buffers.instanceTransforms){let e=r.buffers.instanceTransforms.length;if(r.data.maxInstances&&r.data.maxInstances<e&&(e=r.data.maxInstances),r.buffers.indices){const t=[null,_.UNSIGNED_BYTE,_.UNSIGNED_SHORT,null,_.UNSIGNED_INT];_.drawElementsInstanced(r.data.primitives??_.TRIANGLES,f,t[r.buffers.indices.bytesPerEl],u,e)}else _.drawArraysInstanced(r.data.primitives??_.TRIANGLES,u,f,e)}else if(r.buffers.indices){const e=[null,_.UNSIGNED_BYTE,_.UNSIGNED_SHORT,null,_.UNSIGNED_INT];_.drawElements(r.data.primitives??_.TRIANGLES,f,e[r.buffers.indices.bytesPerEl],u)}else _.drawArrays(r.data.primitives??_.TRIANGLES,u,f);X===k&&(x=!0,b.dirty=!0,y.requestRedraw()),r.buffers.colors&&_.disableVertexAttribArray(s.aloc.a_color),r.buffers.texCoords&&_.disableVertexAttribArray(s.aloc.a_uv),r.buffers.boneIndices&&_.disableVertexAttribArray(s.aloc.a_index),r.buffers.boneWeights&&_.disableVertexAttribArray(s.aloc.a_weight),r.buffers.instanceTransforms&&(16==r.buffers.instanceTransforms.size?(_.disableVertexAttribArray(s.aloc.a_instanceTransform),_.disableVertexAttribArray(s.aloc.a_instanceTransform+1),_.disableVertexAttribArray(s.aloc.a_instanceTransform+2),_.disableVertexAttribArray(s.aloc.a_instanceTransform+3),_.vertexAttribDivisor(s.aloc.a_instanceTransform,0),_.vertexAttribDivisor(s.aloc.a_instanceTransform+1,0),_.vertexAttribDivisor(s.aloc.a_instanceTransform+2,0),_.vertexAttribDivisor(s.aloc.a_instanceTransform+3,0)):(_.disableVertexAttribArray(s.aloc.a_instanceTransform),_.vertexAttribDivisor(s.aloc.a_instanceTransform,0))),r.buffers.instanceColors&&(_.disableVertexAttribArray(s.aloc.a_instanceColor),_.vertexAttribDivisor(s.aloc.a_instanceColor,0)),r.buffers.instanceUVOffsets&&(_.disableVertexAttribArray(s.aloc.a_instanceUV),_.vertexAttribDivisor(s.aloc.a_instanceUV,0))}},{blockType:R.LABEL,text:"Textures"},{opcode:"textureFromUrl",blockType:R.REPORTER,text:"texture from URL [TEXURL]",arguments:{TEXURL:{type:N.STRING,defaultValue:"https://extensions.turbowarp.org/dango.png"}},def:function({TEXURL:t},{target:r}){return ee=null,J=new Promise(((r,n)=>{e.canFetch(t).then((e=>{if(!e)return void r(null);const n=new Image;new URL(t,window.location.href).origin!==window.location.origin&&(n.crossOrigin=""),n.src=t,n.onload=function(){r({width:n.width,height:n.height,data:n})},n.onerror=function(){r(null)}})).catch((()=>{r(null)}))})),"[texture data]"}},{opcode:"textureFromCostume",blockType:R.REPORTER,text:"texture from costume [NAME]",arguments:{NAME:{type:N.COSTUME}},def:function({NAME:e},{target:t}){return ee=null,J=new Promise(((r,n)=>{if(a="texture from costume",y.isPackaged&&(alert(`To use the Simple3D ${a} block, the creator of the packaged project must uncheck "Remove raw asset data after loading to save RAM" under advanced settings in the packager.`),1))return void r(null);var a;const o=t.getCostumeIndexByName(e);if(-1==o)return;const s=t.sprite.costumes[o],i=new Image;i.src=s.asset.encodeDataURI(),i.onload=function(){r({width:i.width,height:i.height,data:i})},i.onerror=function(){r(null)}})),"[texture data]"}},{opcode:"textureFromText",blockType:R.REPORTER,text:"texture from text [TEXT] font [FONT] color [COLOR]",arguments:{TEXT:{type:N.STRING,defaultValue:"Hello World!"},FONT:{type:N.STRING,defaultValue:"italic bold 32px sans-serif"},COLOR:{type:N.COLOR,defaultValue:"#ffff00"}},def:function({TEXT:e,FONT:t,COLOR:r}){return e=A.toString(e),t=A.toString(t),r=A.toRgbColorObject(r),ee=null,J=new Promise(((n,a)=>{const o=document.createElement("canvas"),s=o.getContext("2d");s.font=t;const i=s.measureText(e);o.width=i.actualBoundingBoxLeft+i.actualBoundingBoxRight,o.height=i.fontBoundingBoxAscent+i.fontBoundingBoxDescent,s.clearRect(0,0,o.width,o.height),s.font=t,s.fillStyle=`rgba(${r.r},${r.g},${r.b},${(r.a??255)/255})`,s.fillText(e,i.actualBoundingBoxLeft,i.fontBoundingBoxAscent),ee={width:o.width,height:o.height,data:o},n(ee)})),"[texture data]"}},{opcode:"textureFromTextWithBorder",blockType:R.REPORTER,text:"texture from text [TEXT] font [FONT] color [COLOR] border [BORDERSIZE] [BORDERCOLOR]",arguments:{TEXT:{type:N.STRING,defaultValue:"Hello World!"},FONT:{type:N.STRING,defaultValue:"italic bold 32px sans-serif"},COLOR:{type:N.COLOR,defaultValue:"#ffff00"},BORDERSIZE:{type:N.NUMBER,defaultValue:1},BORDERCOLOR:{type:N.COLOR,defaultValue:"#000000"}},def:function({TEXT:e,FONT:t,COLOR:r,BORDERSIZE:n,BORDERCOLOR:a}){e=A.toString(e),t=A.toString(t),r=A.toRgbColorObject(r),n=A.toNumber(n),a=A.toRgbColorObject(a);const o=Math.ceil(n);return ee=null,J=new Promise(((s,i)=>{const l=document.createElement("canvas"),u=l.getContext("2d");u.font=t;const f=u.measureText(e);l.width=f.actualBoundingBoxLeft+f.actualBoundingBoxRight+2*o,l.height=f.fontBoundingBoxAscent+f.fontBoundingBoxDescent+2*o,u.clearRect(0,0,l.width,l.height),u.font=t,u.lineWidth=n,u.fillStyle=`rgba(${r.r},${r.g},${r.b},${(r.a??255)/255})`,u.strokeStyle=`rgba(${a.r},${a.g},${a.b},${(a.a??255)/255})`,u.fillText(e,f.actualBoundingBoxLeft+o,f.fontBoundingBoxAscent+o),u.strokeText(e,f.actualBoundingBoxLeft+o,f.fontBoundingBoxAscent+o),ee={width:l.width,height:l.height,data:l},s(ee)})),"[texture data]"}},{opcode:"textureFromList",blockType:R.REPORTER,text:"texture from list [NAME] at [POS] of size [WIDTH] [HEIGHT]",arguments:{NAME:{type:N.STRING,menu:"lists"},POS:{type:N.NUMBER,defaultValue:1},WIDTH:{type:N.NUMBER,defaultValue:16},HEIGHT:{type:N.NUMBER,defaultValue:16}},def:function({NAME:e,POS:t,WIDTH:r,HEIGHT:n},{target:a}){let o="[texture data]";return ee=null,J=new Promise(((s,i)=>{const l=A.toNumber(r),u=A.toNumber(n),f=A.toString(e),d=l*u*4;if(l<1||u<1||!Number.isFinite(l)||!Number.isFinite(u))return o="invalid texture size",void s(null);const c=a.lookupVariableByNameAndType(f,"list");if(!c)return o="list not found",void s(null);const p=A.toNumber(t)-1;if(!Number.isFinite(p)||p<0)return o="invalid position",void s(null);if(c.value.length<p+d)return o="insufficient list length",void s(null);const m=new Uint8Array(d),h=c.value;for(let e=0;e<d;e++)m[e]=h[p+e];ee={width:l,height:u,data:m},s(ee)})),o}},{opcode:"textureFromSize",blockType:R.REPORTER,text:"texture of size [WIDTH] [HEIGHT]",arguments:{WIDTH:{type:N.NUMBER,defaultValue:16},HEIGHT:{type:N.NUMBER,defaultValue:16}},def:function({WIDTH:e,HEIGHT:t},{target:r}){let n="[texture data]";return ee=null,J=new Promise(((r,a)=>{const o=A.toNumber(e),s=A.toNumber(t);if(o<1||s<1||!Number.isFinite(o)||!Number.isFinite(s))return n="invalid texture size",void r(null);ee={width:o,height:s,data:null},r(ee)})),n}},{blockType:R.LABEL,text:"Text measurement"},{opcode:"measureText",blockType:R.COMMAND,text:"measure text [TEXT] font [FONT]",arguments:{PROP:{type:N.STRING,defaultValue:"up"},TEXT:{type:N.STRING,defaultValue:"Hello World!"},FONT:{type:N.STRING,defaultValue:"italic bold 32px sans-serif"}},def:function({PROP:e,TEXT:t,FONT:r}){e=A.toString(e),t=A.toString(t),r=A.toString(r);const n=document.createElement("canvas").getContext("2d");n.font=r,oe=n.measureText(t)}},{opcode:"readMeasuredText",blockType:R.REPORTER,text:"measured [DIR] size",arguments:{DIR:{type:N.STRING,menu:"directions",defaultValue:"up"}},def:function({DIR:e}){return oe?"up"==(e=A.toString(e))?oe.fontBoundingBoxAscent:"down"==e?oe.fontBoundingBoxDescent:"left"==e?oe.actualBoundingBoxLeft:"right"==e?oe.actualBoundingBoxRight:"x step"==e?oe.width:0:0}},{blockType:R.LABEL,text:"Fonts"},{opcode:"getFont",blockType:R.REPORTER,text:"font [FONT] of size [SIZE]",arguments:{FONT:{type:N.STRING,menu:"fonts",defaultValue:"Sans Serif"},SIZE:{type:N.NUMBER,defaultValue:32}},def:function({FONT:e,SIZE:t}){return e=A.toString(e),`${t=Math.min(Math.max(A.toNumber(t),1),1e3)}px ${e}`}},{blockType:R.LABEL,text:"View transformations"},{opcode:"matSelect",blockType:R.COMMAND,text:"configure [TRANSFORM] transformation",arguments:{TRANSFORM:{type:N.STRING,menu:"renderTransforms"}},def:function({TRANSFORM:e},{target:t}){r(Y,e)&&(W=e)}},{opcode:"matStartWithPerspective",blockType:R.COMMAND,text:"start with perspective FOV: [FOV] near: [NEAR] far: [FAR]",arguments:{FOV:{type:N.NUMBER,defaultValue:90},NEAR:{type:N.NUMBER,defaultValue:.1},FAR:{type:N.NUMBER,defaultValue:1e3}},def:function({FOV:e,NEAR:r,FAR:n}){Y[W]=t.perspective(A.toNumber(e)/180*Math.PI,X.getAspectRatio(),A.toNumber(r),A.toNumber(n))}},{opcode:"matStartWithOrthographic",blockType:R.COMMAND,text:"start with orthographic near: [NEAR] far: [FAR]",arguments:{NEAR:{type:N.NUMBER,defaultValue:.1},FAR:{type:N.NUMBER,defaultValue:1e3}},def:function({NEAR:e,FAR:r}){Y[W]=t.orthographic(X.getAspectRatio(),A.toNumber(e),A.toNumber(r))}},{opcode:"matStartWithIdentity",blockType:R.COMMAND,text:"start with no transformation",def:function(){Y[W]=t.identity()}},{opcode:"matStartWithExternal",blockType:R.COMMAND,text:"start with [SOURCE]",arguments:{SOURCE:{type:N.STRING,menu:"externalTransforms"}},def:function({SOURCE:e},n){if(!r(F,e))return;const a=F[e];Y[W]=a.get()??t.identity()}},{opcode:"matStartWithSavedIn",blockType:R.COMMAND,text:"start with saved in [SRCLIST] at [POS]",arguments:{SRCLIST:{type:N.STRING,menu:"lists"},POS:{type:N.NUMBER,defaultValue:1}},def:function({SRCLIST:e,POS:t},{target:r}){const n=Math.floor(A.toNumber(t)),a=r.lookupVariableByNameAndType(A.toString(e),"list");a&&(!Number.isFinite(n)||n<1||n+15>a.value.length||(Y[W]=a.value.slice(n-1,n+15).map(A.toNumber)))}},{opcode:"matMove",blockType:R.COMMAND,text:"move X: [X] Y: [Y] Z: [Z]",arguments:{X:{type:N.NUMBER},Y:{type:N.NUMBER},Z:{type:N.NUMBER}},def:function({X:e,Y:r,Z:n}){Y[W]=t.translate(Y[W],A.toNumber(e),A.toNumber(r),A.toNumber(n))}},{opcode:"matRotate",blockType:R.COMMAND,text:"rotate around [AXIS] by [ANGLE] degrees",arguments:{AXIS:{type:N.STRING,menu:"axis"},ANGLE:{type:N.ANGLE}},def:function({AXIS:e,ANGLE:r}){let n;"X"==e&&(n=t.xRotate),"Y"==e&&(n=t.yRotate),"Z"==e&&(n=t.zRotate),n&&(Y[W]=n(Y[W],A.toNumber(r)/180*Math.PI))}},{opcode:"matScale",blockType:R.COMMAND,text:"scale X: [X] Y: [Y] Z: [Z]",arguments:{X:{type:N.NUMBER,defaultValue:1},Y:{type:N.NUMBER,defaultValue:1},Z:{type:N.NUMBER,defaultValue:1}},def:function({X:e,Y:r,Z:n}){Y[W]=t.scale(Y[W],A.toNumber(e),A.toNumber(r),A.toNumber(n))}},{opcode:"matWrapper",blockType:R.CONDITIONAL,text:"wrapper",def:function(e,t){t.stackFrame.undoWrapper?(t.stackFrame.undoWrapper=!1,Y=t.stackFrame.mat3Dstack.pop()):(t.stackFrame.undoWrapper=!0,t.stackFrame.mat3Dstack||(t.stackFrame.mat3Dstack=[]),t.stackFrame.mat3Dstack.push(Object.assign({},Y)),t.startBranch(1,!0))}},{opcode:"matSaveInto",blockType:R.COMMAND,text:"save into [DSTLIST] at [POS]",arguments:{DSTLIST:{type:N.STRING,menu:"lists"},POS:{type:N.NUMBER,defaultValue:1}},def:function({DSTLIST:e,POS:t},{target:r}){const n=Math.floor(A.toNumber(t))-1,a=r.lookupVariableByNameAndType(A.toString(e),"list");if(!a)return;if(n<0||!Number.isFinite(n))return;const o=a.value,s=Y[W];for(;o.length<n+15;)o.push(0);for(let e=0;e<16;e++)o[n+e]=s[e];a._monitorUpToDate=!1}},{opcode:"matReset",blockType:R.COMMAND,text:"reset transformation's [COMPONENT]",arguments:{COMPONENT:{type:N.STRING,menu:"matComponent"}},def:function({COMPONENT:e}){const t=Y[W];"rotation"==e&&(Y[W]=[1,0,0,0,0,1,0,0,0,0,1,0,t[12],t[13],t[14],1]),"offset"==e&&(Y[W]=[t[0],t[1],t[2],0,t[4],t[5],t[6],0,t[8],t[9],t[10],0,0,0,0,1])}},{blockType:R.LABEL,text:"Manual transformations"},{opcode:"matTransform",blockType:R.COMMAND,text:"transform X: [X] Y: [Y] Z: [Z]",arguments:{X:{type:N.NUMBER},Y:{type:N.NUMBER},Z:{type:N.NUMBER}},def:function({X:e,Y:r,Z:n}){const a=[A.toNumber(e),A.toNumber(r),A.toNumber(n),1];z=t.multiplyVec(Y[W],a)}},{opcode:"matTransformFromTo",blockType:R.COMMAND,text:"transform X: [X] Y: [Y] Z: [Z] from [FROM] to [TO]",arguments:{X:{type:N.NUMBER},Y:{type:N.NUMBER},Z:{type:N.NUMBER},FROM:{type:N.STRING,menu:"vectorTransformsMin2",defaultValue:"world space"},TO:{type:N.STRING,menu:"vectorTransforms",defaultValue:"model space"}},def:function({X:e,Y:r,Z:n,FROM:a,TO:o}){const s={projected:4,"projected (scratch units)":4,"view space":3,"world space":2,"model space":1},i=[null,Y.modelToWorld,Y.worldToView,Y.viewToProjected];let l=s[a],u=s[o];if(!l||!u)return;const f=[A.toNumber(e),A.toNumber(r),A.toNumber(n),1];if(l==u)return void(z=f);if(i[l]===se.from&&i[u]===se.to)return void(z=t.multiplyVec(se.matrix,f));se.from=i[l],se.to=i[u];let d=!1;l>u&&([l,u]=[u,l],d=!0);let c=i[l];for(let e=l+1;e<u;e++)c=t.multiply(i[e],c);d&&(c=t.inverse(c)),se.matrix=c,z=t.multiplyVec(c,f),"projected (scratch units)"==o&&(z[0]=z[0]/z[3]*y.stageWidth/2,z[1]=z[1]/z[3]*y.stageHeight/2,z[2]=z[3])}},{opcode:"matTransformFromToDir",blockType:R.COMMAND,text:"transform direction X: [X] Y: [Y] Z: [Z] from [FROM] to [TO]",arguments:{X:{type:N.NUMBER},Y:{type:N.NUMBER},Z:{type:N.NUMBER},FROM:{type:N.STRING,menu:"vectorTransformsMin2",defaultValue:"world space"},TO:{type:N.STRING,menu:"vectorTransformsMin1",defaultValue:"model space"}},def:function({X:e,Y:r,Z:n,FROM:a,TO:o}){const s={projected:4,"projected (scratch units)":4,"view space":3,"world space":2,"model space":1},i=[null,Y.modelToWorld,Y.worldToView,Y.viewToProjected];let l=s[a],u=s[o];if(!l||!u)return;const f=[A.toNumber(e),A.toNumber(r),A.toNumber(n),0];if(l==u)return void(z=f);if(i[l]===se.from&&i[u]===se.to)return void(z=t.multiplyVec(se.matrix,f));se.from=i[l],se.to=i[u];let d=!1;l>u&&([l,u]=[u,l],d=!0);let c=i[l];for(let e=l+1;e<u;e++)c=t.multiply(i[e],c);d&&(c=t.inverse(c)),se.matrix=c,z=t.multiplyVec(c,f)}},{opcode:"matTransformResult",blockType:R.REPORTER,text:"transformed [AXIS]",disableMonitor:!0,arguments:{AXIS:{type:N.STRING,menu:"axis"}},def:function({AXIS:e}){const t={X:1,Y:2,Z:3}[e];return t?z[t-1]:""}},{blockType:R.LABEL,text:"Rendering into textures"},{opcode:"renderToStage",blockType:R.COMMAND,text:"render to stage",def:function(){k.setAsRenderTarget()}},{opcode:"renderToTexture",blockType:R.COMMAND,text:"render to texture of [NAME]",arguments:{NAME:{type:N.STRING,defaultValue:"my mesh"}},def:function({NAME:e}){const t=B.get(A.toString(e));t&&t.data.texture&&t.data.texture instanceof s&&t.data.texture.main.setAsRenderTarget()}},{opcode:"renderToCubeTexture",blockType:R.COMMAND,text:"render to cube texture [SIDE] of [NAME]",arguments:{SIDE:{type:N.STRING,menu:"cubeSide"},NAME:{type:N.STRING,defaultValue:"my mesh"}},def:function({SIDE:e,NAME:t}){const n=B.get(A.toString(t));if(!n)return;if(!n.data.texture)return;if(!(n.data.texture instanceof i))return;const a={"X+":"xpos","X-":"xneg","Y+":"ypos","Y-":"yneg","Z+":"zpos","Z-":"zneg"};r(a,e)&&n.data.texture[a[e]].setAsRenderTarget()}},{opcode:"readRenderTarget",blockType:R.COMMAND,text:"read current render target into [DSTLIST]",arguments:{DSTLIST:{type:N.STRING,menu:"lists"}},def:function({DSTLIST:e},{target:t}){const r=t.lookupVariableByNameAndType(A.toString(e),"list");if(!r)return;if(!X.checkIfValid())return;const{x:n,y:a,w:o,h:s}=X.getReadarea();if(0==o||0==s)return;const i=new Uint8ClampedArray(o*s*4);_.readPixels(n,a,o,s,_.RGBA,_.UNSIGNED_BYTE,i),r.value=Array.from(i),r._monitorUpToDate=!1}},{opcode:"renderTargetInfo",blockType:R.REPORTER,text:"render target [PROPERTY]",allowDropAnywhere:!0,disableMonitor:!0,arguments:{PROPERTY:{type:N.STRING,menu:"renderTargetProperty",defaultValue:"width"}},def:function({PROPERTY:e}){if("mesh name"==e)return X.getMesh()?.name??"";if("width"==e)return X.width;if("height"==e)return X.height;if("aspect ratio"==e)return X.getAspectRatio();if("depth test"==e)return X.depthTest;if("depth write"==e)return X.depthWrite;if("has depth storage"==e)return X.hasDepthBuffer;if("image as data URI"==e){if(!X.checkIfValid())return"";const{x:e,y:t,w:r,h:n}=X.getReadarea();if(0==r||0==n)return"";const a=new Uint8ClampedArray(r*n*4);_.readPixels(e,t,r,n,_.RGBA,_.UNSIGNED_BYTE,a);for(let e=0;e<a.length;e+=4){const t=a[e+3]/255;a[e+0]/=t,a[e+1]/=t,a[e+2]/=t}const o=document.createElement("canvas");o.width=r,o.height=n;const s=o.getContext("2d"),i=new ImageData(a,r,n);return s.putImageData(i,0,0),o.toDataURL()}return"is valid for being drawn to"==e?X.checkIfValid():"has viewport box"==e?null!==X.viewport:"has clipping box"==e?null!==X.scissors:"has readback box"==e?null!==X.readarea:""}},{opcode:"setRenderTargetBox",blockType:R.COMMAND,text:"set [BOXTYPE] to X1:[X1] Y1:[Y1] X2:[X2] Y2:[Y2]",arguments:{BOXTYPE:{type:N.STRING,menu:"boxType"},X1:{type:N.NUMBER,defaultValue:0},Y1:{type:N.NUMBER,defaultValue:0},X2:{type:N.NUMBER,defaultValue:100},Y2:{type:N.NUMBER,defaultValue:100}},def:function({BOXTYPE:e,X1:t,Y1:r,X2:n,Y2:a}){t=A.toNumber(t),r=A.toNumber(r),n=A.toNumber(n),a=A.toNumber(a);const o=Math.min(t,n),s=Math.min(r,a),i=Math.max(t,n)-o,l=Math.max(r,a)-s;"viewport box"==e&&(X.viewport={x:o,y:s,w:i,h:l}),"clipping box"==e&&(X.scissors={x:o,y:s,w:i,h:l},X.updateScissorsEnabled()),"readback box"==e&&(X.readarea={x:o,y:s,w:i,h:l}),X.updateViewport()}},{opcode:"clearRenderTargetBox",blockType:R.COMMAND,text:"clear [BOXTYPE]",arguments:{BOXTYPE:{type:N.STRING,menu:"boxType"}},def:function({BOXTYPE:e}){"viewport box"==e&&(X.viewport=null),"clipping box"==e&&(X.scissors=null,X.updateScissorsEnabled()),"readback box"==e&&(X.readarea=null),X.updateViewport()}},{blockType:R.LABEL,text:"Tinting and fog"},{opcode:"setGlobalColor",blockType:R.COMMAND,text:"set global color [OPERATION] R: [RED] G: [GREEN] B: [BLUE] A: [ALPHA]",arguments:{OPERATION:{type:N.STRING,menu:"globalColor"},RED:{type:N.NUMBER,defaultValue:1},GREEN:{type:N.NUMBER,defaultValue:1},BLUE:{type:N.NUMBER,defaultValue:1},ALPHA:{type:N.NUMBER,defaultValue:1}},def:function({OPERATION:e,RED:t,GREEN:r,BLUE:n,ALPHA:a}){const o=[A.toNumber(t),A.toNumber(r),A.toNumber(n),A.toNumber(a)];"multiplier"==e&&(H=o),"adder"==e&&(Z=o)}},{opcode:"setFogEnabled",blockType:R.COMMAND,text:"turn fog [STATE]",arguments:{STATE:{type:N.STRING,menu:"onOff"}},def:function({STATE:e}){q=A.toBoolean(e)}},{opcode:"setFogColor",blockType:R.COMMAND,text:"set fog color R: [RED] G: [GREEN] B: [BLUE]",arguments:{RED:{type:N.NUMBER,defaultValue:1},GREEN:{type:N.NUMBER,defaultValue:1},BLUE:{type:N.NUMBER,defaultValue:1}},def:function({RED:e,GREEN:t,BLUE:r}){j=[A.toNumber(e),A.toNumber(t),A.toNumber(r)]}},{opcode:"setFogDistance",blockType:R.COMMAND,text:"set fog distance near: [NEAR] far: [FAR]",arguments:{NEAR:{type:N.NUMBER,defaultValue:10},FAR:{type:N.NUMBER,defaultValue:100}},def:function({NEAR:e,FAR:t}){e=A.toNumber(e),t=A.toNumber(t),K=[e,t-e]}},{opcode:"setFogPosition",blockType:R.COMMAND,text:"set fog [SPACE] origin at X: [X] Y: [Y] Z: [Z]",arguments:{SPACE:{type:N.STRING,defaultValue:"view space",menu:"fogSpace"},X:{type:N.NUMBER,defaultValue:0},Y:{type:N.NUMBER,defaultValue:0},Z:{type:N.NUMBER,defaultValue:0}},def:function({SPACE:e,X:t,Y:r,Z:n}){$=A.toString(e),Q=[A.toNumber(t),A.toNumber(r),A.toNumber(n)],0==Q[0]&&0==Q[1]&&0==Q[2]&&(Q=null)}},{blockType:R.LABEL,text:"Resolution changes"},{opcode:"whenCanvasResized",blockType:R.EVENT,text:"when resolution changes",isEdgeActivated:!1},{opcode:"canvasWidth",blockType:R.REPORTER,text:"stage width",def:function(){return M.width}},{opcode:"canvasHeight",blockType:R.REPORTER,text:"stage height",def:function(){return M.height}}],de={id:S,name:"Simple 3D",color1:"#5CB1D6",color2:"#47A8D1",color3:"#2E8EB8",docsURI:"https://extensions.turbowarp.org/Xeltalliv/simple3D",blocks:fe,menus:{fonts:{acceptReporters:!1,items:"fontsMenu"},lists:{acceptReporters:!1,items:"listsMenu"},costumes:{acceptReporters:!0,items:"costumesMenu"},externalTransforms:{acceptReporters:!0,items:"externalTransformsMenu"},clearLayers:{acceptReporters:!0,items:Object.keys(P)},primitives:{acceptReporters:!0,items:Object.keys(C)},onOff:{acceptReporters:!0,items:[{text:"on",value:"true"},{text:"off",value:"false"}]},meshProperties:{acceptReporters:!1,items:["exists",...Object.keys(f)]},axis:{acceptReporters:!1,items:["X","Y","Z"]},textureWrap:{acceptReporters:!1,items:["clamp to edge","repeat"]},textureFilter:{acceptReporters:!1,items:["pixelated","blurred"]},textureMipmapping:{acceptReporters:!1,items:["off","sharp transitions","smooth transitions"]},cubeSide:{acceptReporters:!0,items:["X+","X-","Y+","Y-","Z+","Z-"]},blending:{acceptReporters:!0,items:Object.keys(v)},culling:{acceptReporters:!0,items:Object.keys(D)},skinningTransforms:{acceptReporters:!0,items:["original","current"]},renderTransforms:{acceptReporters:!1,items:[{text:"to projected from view space",value:"viewToProjected"},{text:"to view space from world space",value:"worldToView"},{text:"to world space from model space",value:"modelToWorld"},{text:"importing from file",value:"import"},{text:"custom",value:"custom"}]},matComponent:{acceptReporters:!0,items:["offset","rotation"]},vectorTransforms:{acceptReporters:!1,items:["projected (scratch units)","projected","view space","world space","model space"]},vectorTransformsMin1:{acceptReporters:!1,items:["projected","view space","world space","model space"]},vectorTransformsMin2:{acceptReporters:!1,items:["view space","world space","model space"]},fogSpace:{acceptReporters:!1,items:["view space","world space","model space"]},renderTargetProp:{acceptReporters:!1,items:["width","height"]},filetype:{acceptReporters:!1,items:["obj mtl","off"]},globalColor:{acceptReporters:!1,items:["multiplier","adder"]},alphaTestMode:{acceptReporters:!1,items:[{text:"preserve opacity",value:"false"},{text:"make opaque",value:"true"}]},instanceProperty:{acceptReporters:!1,items:["transforms","XY positions","XYZ positions","XYZ positions and sizes","RGB colors","RGBA colors","UV offsets","UV offsets and sizes"]},interleavedProperty:{acceptReporters:!1,items:["XY positions","XYZ positions","RGB colors","RGBA colors","UV texture coordinates","UVW texture coordinates"]},renderTargetProperty:{acceptReporters:!1,items:["mesh name","width","height","aspect ratio","depth test","depth write","has depth storage","image as data URI","is valid for being drawn to","has viewport box","has clipping box","has readback box"]},powersOfTwo:{acceptReporters:!0,items:["1","2","4","8","16"]},depthTest:{acceptReporters:!0,items:Object.keys(U)},directions:{acceptReporters:!0,items:["up","down","left","right","x step"]},bufferUsage:{acceptReporters:!0,items:["rarely","frequently fully","frequently partially"]},multiSampleInterpolation:{acceptReporters:!0,items:["once at pixel center","once at midpoint of covered samples","separately for each sample"]},boxType:{acceptReporters:!1,items:["viewport box","clipping box","readback box"]}}};class ce{getInfo(){return fe.find((e=>"matStartWithExternal"==e.opcode)).hideFromPalette=0==Object.keys(F).length,de}dispose(){ue(),function(){b.destroyDrawable(ie,"simple3D"),b.destroySkin(le);const e=b._groupOrdering.indexOf("simple3D");if(-1==e)return;if(b._layerGroups.simple3D.drawListOffset===b._layerGroups[b._groupOrdering[e+1]].drawListOffset){b._groupOrdering.splice(e,1),delete b._layerGroups.simple3D;for(let e=0;e<b._groupOrdering.length;e++)b._layerGroups[b._groupOrdering[e]].groupIndex=e;G.redraw=null}}(),V.destroy(),y.removeListener("PROJECT_LOADED",ue),M=null,_=null;const e=()=>{};for(let t of fe)"---"!=t&&(ce.prototype[t.opcode??t.func]=e)}fontsMenu(){return["Sans Serif","Serif","Handwriting","Marker","Curly","Pixel","Scratch",...y.fontManager?y.fontManager.getFonts().map((e=>({text:e.name,value:e.family}))):[]]}listsMenu(){const e=g.runtime.getTargetForStage(),t=g.editingTarget!==e?g.editingTarget:null,r=[...t?Object.values(t.variables).filter((e=>"list"==e.type)).map((e=>e.name)):[],...e?Object.values(e.variables).filter((e=>"list"==e.type)).map((e=>e.name)):[]];return r.sort(),0==r.length?["list"]:r}costumesMenu(){let e=g.editingTarget;return e?e.getCostumes().map((e=>e.name)):["costume 1"]}externalTransformsMenu(){const e=[];for(let t in F)e.push({value:t,text:F[t].name});return 0==e.length&&e.push({value:"",text:"- no external sources -"}),e}}for(let e of fe)"---"!=e&&(ce.prototype[e.opcode??e.func]=e.def);G.i_will_not_ask_for_help_when_these_break=()=>(console.warn("WARNING: You are accessing Simple3D internals. Expect them to change frequently with no regard to backwards compatibility. WHEN your code breaks, do not expect help.\n\nProper stable APIs will be added later."),{canvas:M,gl:_,definitions:fe,meshes:B,programs:L,modelDecoder:V,uploadBuffer:T,getFshSrc:()=>m,setFshSrc:e=>{m=e},getVshSrc:()=>p,setVshSrc:e=>{p=e},canvasRenderTarget:k,resetEverything:ue,getTransforms:()=>Y,setTransforms:e=>{Y=e},getSelectedTransform:()=>W,setSelectedTransform:e=>{W=e},getWorkerSrc:()=>d,setWorkerSrc:e=>{d=e},extInfo:de,Extension:ce,Blendings:v}),e.extensions.register(new ce)}(Scratch);
